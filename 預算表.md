---
layout: page
title: 預算表
permalink: /budget_table/
---

<link rel="stylesheet" href="{{ '/assets/budget-table.css' | relative_url }}">

<script>

const base = "https://script.google.com/macros/s/AKfycbyrRS1rmb2S_M3BNjn_Z-ZR5uZWmpG1j1MDPTF8YqMFzFQxSKFtTjK_tGXuEfa6sP3p/exec";

// ===== 全域狀態變數 =====
let currentSheetIndex = 2; // 目前選擇的試算表分頁索引（2 代表第三個分頁）
let sheetNames = []; // 所有月份分頁名稱（不含前兩個「空白表」、「下拉選單」）
let allMonthsData = {}; // 預先載入的所有月份資料（key: sheetIndex, value: { data, total }）
let allRecords = []; // 目前選擇月份的記錄（收入 + 支出）
let filteredRecords = []; // 目前類型過濾後的記錄
let currentRecordIndex = 0;
let isNewMode = false; // 是否在新增模式
let currentRecordNumber = null; // 目前顯示的記錄編號

// ===== 下拉選單選項（從「下拉選單」sheet=1 載入）=====
let EXPENSE_CATEGORY_OPTIONS = [
  { value: '生活花費：食', text: '生活花費：食' },
  { value: '生活花費：衣與外貌', text: '生活花費：衣與外貌' },
  { value: '生活花費：住、居家裝修、衛生用品、次月繳納帳單', text: '生活花費：住、居家裝修、衛生用品、次月繳納帳單' },
  { value: '生活花費：行', text: '生活花費：行' },
  { value: '生活花費：育', text: '生活花費：育' },
  { value: '生活花費：樂', text: '生活花費：樂' },
  { value: '生活花費：健（醫療）', text: '生活花費：健（醫療）' },
  { value: '生活花費：帳單', text: '生活花費：帳單' },
  { value: '儲蓄：退休金、醫療預備金、過年紅包支出', text: '儲蓄：退休金、醫療預備金、過年紅包支出' },
  { value: '家人：過年紅包、紀念日', text: '家人：過年紅包、紀念日' }
];

// 從「下拉選單」sheet=1 載入最新選項
// 注意：下拉選單資料在支出表的 Google Sheet 中，所以使用支出表的 URL
// 使用與設定頁相同的支出表 URL
const baseExpenseForDropdown = "https://script.google.com/macros/s/AKfycbzZ3lvBx2z2rueEZc2PhoTpo8HdyXkLJ-GkBf_llfpvek08c40wbr7H5wEfH73YQA10/exec";

async function loadDropdownOptions() {
  try {
    const params = { name: "Show Tab Data", sheet: 1, _t: Date.now() };
    const url = `${baseExpenseForDropdown}?${new URLSearchParams(params)}`;
    const res = await fetch(url, {
      method: "GET",
      redirect: "follow",
      mode: "cors",
      cache: "no-store"
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const responseData = await res.json();
    console.log('[loadDropdownOptions] 預算表：原始回應資料:', responseData);
    
    // 處理不同的資料格式
    let data = null;
    
    // 如果是陣列，直接使用
    if (Array.isArray(responseData)) {
      data = responseData;
    } 
    // 如果是物件，可能是命名範圍的格式，嘗試找到第一個陣列值
    else if (typeof responseData === 'object' && responseData !== null) {
      // 尋找第一個值是陣列的鍵
      for (const key in responseData) {
        if (Array.isArray(responseData[key]) && responseData[key].length > 0) {
          data = responseData[key];
          console.log('[loadDropdownOptions] 預算表：從命名範圍取得資料:', key);
          break;
        }
      }
    }
    
    if (!data || !Array.isArray(data) || data.length === 0) {
      console.warn('[loadDropdownOptions] 預算表：無法解析資料格式，回應:', responseData);
      return;
    }

    const headerRow = data[0];
    console.log('[loadDropdownOptions] 預算表：標題行:', headerRow);

    // 找對應欄位（預算表使用「支出－項目」）
    const colCategory = findHeaderColumn(headerRow, ['支出－項目', '支出-項目', '消費類別', '類別']);
    console.log('[loadDropdownOptions] 預算表：找到類別欄位索引:', colCategory);

    const readColumn = (col) => {
      const arr = [];
      if (col < 0) return arr;
      const seen = new Set();
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (!row) continue;
        const raw = row[col];
        if (raw === undefined || raw === null) continue;
        const val = raw.toString().trim();
        if (!val || seen.has(val)) continue;
        seen.add(val);
        arr.push({ value: val, text: val });
      }
      return arr;
    };

    if (colCategory >= 0) {
      EXPENSE_CATEGORY_OPTIONS = readColumn(colCategory);
      console.log('[loadDropdownOptions] 預算表：載入的類別選項:', EXPENSE_CATEGORY_OPTIONS);
      // 如果當前顯示的是支出類別，重新渲染
      const categorySelect = document.getElementById('category-select');
      if (categorySelect && categorySelect.value === '支出') {
        // 保存當前選擇的值（如果有）
        const currentCategorySelect = document.getElementById('expense-category-select');
        const currentValue = currentCategorySelect ? currentCategorySelect.value : '';
        updateDivVisibility('支出');
        // 如果之前有選擇值，嘗試恢復
        if (currentValue) {
          setTimeout(() => {
            const newCategorySelect = document.getElementById('expense-category-select');
            if (newCategorySelect && newCategorySelect.querySelector(`option[value="${currentValue}"]`)) {
              newCategorySelect.value = currentValue;
              // 同步更新自訂下拉顯示文字
              const selectContainer = newCategorySelect.parentElement;
              if (selectContainer) {
                const selectDisplay = selectContainer.querySelector('.select-display');
                if (selectDisplay) {
                  const selectText = selectDisplay.querySelector('.select-text');
                  if (selectText) {
                    const selectedOpt = newCategorySelect.options[newCategorySelect.selectedIndex];
                    selectText.textContent = selectedOpt ? selectedOpt.textContent : '';
                  }
                }
              }
            }
          }, 100);
        }
      }
    } else {
      console.warn('[loadDropdownOptions] 預算表：找不到類別欄位，標題行為:', headerRow);
    }

  } catch (err) {
    console.error('[loadDropdownOptions] 預算表：載入下拉選單失敗:', err);
  }
}

function findHeaderColumn(headerRow, keywords) {
  for (let c = 0; c < headerRow.length; c++) {
    const headerText = (headerRow[c] || '').toString().trim();
    if (!headerText) continue;
    if (keywords.some(k => headerText.includes(k))) return c;
  }
  return -1;
}

// ===== 統一的 API 調用函數 =====
async function callAPI(postData) {
  const response = await fetch(base, {
    method: "POST",
    redirect: "follow",
    mode: "cors",
    keepalive: true,
    body: JSON.stringify(postData)
  });
  
  const responseText = await response.text();
  if (!responseText || responseText.trim() === '') {
    return { success: true, data: null, total: null };
  }
  
  let result;
  try {
    result = JSON.parse(responseText);
  } catch (e) {
    throw new Error('後端響應格式錯誤: ' + responseText.substring(0, 100));
  }
  
  if (!response.ok || !result.success) {
    throw new Error(result.message || result.error || '操作失敗');
  }
  
  return result;
}

// ===== 找到最接近的月份（當前月份或最新月份）=====
function findClosestMonth() {
  if (sheetNames.length === 0) return 2;
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentMonthStr = `${currentYear}${String(currentMonth).padStart(2, '0')}`;
  
  const currentIndex = sheetNames.findIndex(name => name === currentMonthStr);
  if (currentIndex !== -1) {
    return currentIndex + 2;
  }
  
  return sheetNames.length + 1; // 最後一個月份的 sheetIndex
}

// ===== 如果沒有記錄，進入新增模式 =====
function enterNewModeIfEmpty() {
  if (filteredRecords.length > 0) return;
  
  const currentType = categorySelect ? categorySelect.value : '支出';
  let nextNumber = 1;
  const allRecordsOfType = allRecords.filter(r => r.type === currentType);
  if (allRecordsOfType.length > 0) {
    const maxNum = Math.max(
      ...allRecordsOfType
        .map(r => parseInt(r.row[0], 10))
        .filter(n => Number.isFinite(n) && n > 0)
    );
    if (Number.isFinite(maxNum) && maxNum > 0) {
      nextNumber = maxNum + 1;
    }
  }
  isNewMode = true;
  if (typeof recordNumber !== 'undefined') {
    recordNumber.textContent = `#${String(nextNumber).padStart(3, '0')}`;
  }
  if (typeof recordDate !== 'undefined') {
    recordDate.textContent = getNowFormattedDateTime();
  }
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  if (itemInput) itemInput.value = '';
  if (costInput) costInput.value = '';
  if (noteInput) noteInput.value = '';
  updateDeleteButton();
  updateArrowButtons();
}

// 根據目前選擇的類型過濾記錄
function filterRecordsByType(type) {
  filteredRecords = allRecords.filter(r => r.type === type);
  
  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length && filteredRecords.length > 0) {
    currentRecordIndex = filteredRecords.length - 1;
  } else if (filteredRecords.length === 0) {
    currentRecordIndex = 0;
  }

  //  新增模式：切換收入 / 支出模式：重新計算該類型的下一個編號
  if (isNewMode) {
    // 計算新類型中最大的編號 + 1
    let nextNumber = 1;
    if (filteredRecords.length > 0) {
      const maxNum = Math.max(
        ...filteredRecords
          .map(r => parseInt(r.row[0], 10))
          .filter(n => Number.isFinite(n) && n > 0)
      );
      if (Number.isFinite(maxNum) && maxNum > 0) {
        nextNumber = maxNum + 1;
      }
    }
    
    // 更新編號顯示為新類型的下一個編號
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = `#${String(nextNumber).padStart(3, '0')}`;
      currentRecordNumber = nextNumber; // 更新記錄的編號
    }
    
    // 清空表單，準備新增
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    
    // 如果是支出，重置類別選擇
    if (type === '支出') {
      const categorySelectElement = document.getElementById('expense-category-select');
      if (categorySelectElement && categorySelectElement.options.length > 0) {
        categorySelectElement.value = categorySelectElement.options[0].value;
        const selectContainer = categorySelectElement.parentElement;
        if (selectContainer) {
          const selectDisplay = selectContainer.querySelector('div');
          if (selectDisplay) {
            const selectText = selectDisplay.querySelector('div');
            if (selectText) {
              selectText.textContent = categorySelectElement.options[0].textContent;
            }
          }
        }
      }
    }
    
    updateArrowButtons();
    updateDeleteButton(); // 更新刪除按鈕顯示
    return;
  }

  // 嘗試找到相同編號的記錄
  if (currentRecordNumber !== null && filteredRecords.length > 0) {
    const sameNumberIndex = filteredRecords.findIndex(r => {
      const num = parseInt(r.row[0], 10);
      return Number.isFinite(num) && num > 0 && num === currentRecordNumber;
    });
    
    if (sameNumberIndex >= 0) {
      currentRecordIndex = sameNumberIndex;
      showRecord(sameNumberIndex);
      updateArrowButtons();
      return;
    }
  }
  
  // 如果找不到相同編號，顯示第一筆
  currentRecordIndex = 0;
  if (filteredRecords.length > 0) {
    showRecord(0);
  } else {
    // 沒有記錄時，清空表單並更新按鈕
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = '#新增';
    }
    updateArrowButtons();
    updateDeleteButton(); // 更新刪除按鈕顯示
  }
}

// 取得現在時間並格式化為 YYYY/MM/DD HH:MM
function getNowFormattedDateTime() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  return `${year}/${month}/${day} ${hours}:${minutes}`;
}

// 將各種時間字串格式統一轉為 YYYY/MM/DD HH:MM
function formatRecordDateTime(raw) {
  if (!raw) return '';
  
  // 嘗試以 Date 解析（支援 ISO 例如 2025-11-30T12:34:56Z）
  const dt = new Date(raw);
  if (Number.isNaN(dt.getTime())) {
    // 解析失敗時，保留原字串（例如已經是 2025/11/30 12:34）
    return raw;
  }
  
  const year = dt.getFullYear();
  const month = String(dt.getMonth() + 1).padStart(2, '0');
  const day = String(dt.getDate()).padStart(2, '0');
  const hours = String(dt.getHours()).padStart(2, '0');
  const minutes = String(dt.getMinutes()).padStart(2, '0');
  return `${year}/${month}/${day} ${hours}:${minutes}`;
}

// 顯示第 index 筆記錄到卡片上的輸入欄位
function showRecord(index) {
  if (!filteredRecords.length) return;
  
  // 確保 index 在有效範圍內
  if (index < 0 || index >= filteredRecords.length) {
    console.warn(`showRecord: 索引 ${index} 超出範圍 (0-${filteredRecords.length - 1})`);
    index = Math.max(0, Math.min(index, filteredRecords.length - 1));
  }
  
  currentRecordIndex = index; // 更新當前索引
  const { type, row } = filteredRecords[index];
  isNewMode = false; // 顯示記錄時退出新增模式
  updateDeleteButton(); // 更新刪除按鈕顯示

  // 更新左上角編號：只顯示該記錄自己的編號（row[0]），不顯示收入/支出
  if (typeof recordNumber !== 'undefined') {
    const num = parseInt(row[0], 10);
    const recordNum = Number.isFinite(num) && num > 0 ? num : (index + 1);
    recordNumber.textContent = `#${String(recordNum).padStart(3, '0')}`;
    currentRecordNumber = recordNum; // 記錄目前編號
  }

  // 更新右上角「資料時間」：使用每筆記錄的時間欄位（row[1]，通常為試算表中的時間 / 最後修正時間）
  if (typeof recordDate !== 'undefined') {
    recordDate.textContent = formatRecordDateTime(row[1] || '');
  }

  // 設定「支出 / 收入」大類（只改畫面，不觸發 change 事件，避免遞迴）
  if (typeof categorySelect !== 'undefined' && typeof categorySelectText !== 'undefined') {
    const value = type === '收入' || type === '支出' ? type : '支出';
    categorySelect.value = value;
    categorySelectText.textContent = value;
    // 直接更新欄位顯示
    if (typeof updateDivVisibility === 'function') {
      updateDivVisibility();
    }
  }

  // 等 div2 / div3 / div4 依據類別建立好之後再填資料
  // 使用較長的延遲，確保 updateDivVisibility 完成
  setTimeout(() => {
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');

    if (type === '支出') {
      // 支出：[編號, 時間, category, item, cost, note]
      const categorySelectElement = document.getElementById('expense-category-select');
      if (categorySelectElement) {
        categorySelectElement.value = row[2] || '';
        // 同步更新自訂下拉顯示文字（若存在）
        const selectContainer = categorySelectElement.parentElement;
        if (selectContainer) {
          const selectDisplay = selectContainer.querySelector('div');
          if (selectDisplay) {
            const selectText = selectDisplay.querySelector('div');
            if (selectText) {
              selectText.textContent = row[2] || '';
            }
          }
        }
      }
      if (itemInput) {
        itemInput.value = row[3] || '';
        // 確保值已設定（避免 placeholder 顯示）
        if (itemInput.value === '' && row[3]) {
          itemInput.value = row[3];
        }
      }
      if (costInput) costInput.value = row[4] || '';
      if (noteInput) noteInput.value = row[5] || '';
    } else {
      // 收入：[編號, 時間, item, cost, note]
      if (itemInput) {
        itemInput.value = row[2] || '';
        // 確保值已設定（避免 placeholder 顯示）
        if (itemInput.value === '' && row[2]) {
          itemInput.value = row[2];
        }
      }
      if (costInput) costInput.value = row[3] || '';
      if (noteInput) noteInput.value = row[4] || '';
    }
    
    // 更新箭頭按鈕狀態
    updateArrowButtons();
  }, 150);
}

// 處理從 Apps Script 回傳的資料（用於更新 allRecords）
const processDataFromResponse = (data, shouldFilter = true) => {
  // 先清空目前的記錄
  allRecords = [];

  if (data && typeof data === 'object') {
    console.log(`[processDataFromResponse] sheetIndex: ${currentSheetIndex}, keys:`, Object.keys(data));
    
    Object.keys(data).forEach(key => {
      const rows = data[key] || [];

      const isIncome = key.includes('收入');
      const isExpense = key.includes('支出');
      const type = isIncome ? '收入' : (isExpense ? '支出' : '');
      
      if (!type) return; // 跳過不是收入或支出的資料

      rows.forEach(row => {
        if (!row || row.length === 0) return;
        
        // 跳過總計行和空行
        const firstCell = row[0];
        if (firstCell === '總計' || firstCell === '' || firstCell === null || firstCell === undefined) {
          return;
        }
        
        // 跳過標題列（非數字編號）
        const num = parseInt(row[0], 10);
        if (!Number.isFinite(num) || num <= 0) return;
        
        // 就算完全相同也都要顯示（不做去重）
        allRecords.push({ type, row });
      });
    });
  }
  
  console.log(`[processDataFromResponse] 處理後記錄數量: ${allRecords.length}`);

  // 根據目前選擇的類型過濾記錄（預設顯示支出）
  if (shouldFilter) {
    const currentType = categorySelect ? categorySelect.value : '支出';
    filterRecordsByType(currentType);
  }
};

// 更新總計顯示
const updateTotalDisplay = (totalData) => {
  if (Array.isArray(totalData) && totalData.length >= 3) {
    incomeAmount.textContent = totalData[0];
    expenseAmount.textContent = totalData[1];
    totalAmount.textContent = totalData[2];
    updateTotalColor(totalData[2]);
  }
};

// 載入單個月份的資料和總計
const loadMonthData = async (sheetIndex) => {
  // 驗證 sheetIndex 是否有效
  if (!Number.isFinite(sheetIndex) || sheetIndex < 2) {
    throw new Error(`無效的 sheet 索引: ${sheetIndex}`);
  }

  // 從試算表抓出「當月收入 / 支出」等資料 - 添加時間戳避免快取
  const dataParams = { name: "Show Tab Data", sheet: sheetIndex, _t: Date.now() };
  const dataUrl = `${base}?${new URLSearchParams(dataParams)}`;
  console.log(`[loadMonthData] 載入資料: sheet=${sheetIndex}, URL=${dataUrl}`);
  const res = await fetch(dataUrl, {
    method: "GET",
    redirect: "follow",
    mode: "cors",
    cache: "no-store" // 強制不使用快取
  });
  
  if (!res.ok) {
    throw new Error(`載入資料失敗: HTTP ${res.status} ${res.statusText}`);
  }
  
  const data = await res.json();
  console.log(`[loadMonthData] sheet=${sheetIndex} 資料結果:`, data);
  console.log(`[loadMonthData] sheet=${sheetIndex} 資料 keys:`, Object.keys(data));
  // 調試：檢查每個 key 的資料長度
  Object.keys(data).forEach(key => {
    const rows = data[key] || [];
    console.log(`[loadMonthData] ${key}: ${rows.length} 行`);
  });

  // 載入總計 - 添加時間戳避免快取
  const TotalParams = { name: "Show Total", sheet: sheetIndex, _t: Date.now() };
  const Totalurl = `${base}?${new URLSearchParams(TotalParams)}`;
  console.log(`[loadMonthData] 載入總計: sheet=${sheetIndex}, URL=${Totalurl}`);
  const Totalres = await fetch(Totalurl, {
    method: "GET",
    redirect: "follow",
    mode: "cors",
    cache: "no-store" // 強制不使用快取
  });
  
  if (!Totalres.ok) {
    throw new Error(`載入總計失敗: HTTP ${Totalres.status} ${Totalres.statusText}`);
  }
  
  const totalData = await Totalres.json();
  console.log(`[loadMonthData] sheet=${sheetIndex} 總計結果 (原始):`, totalData);
  console.log(`[loadMonthData] sheet=${sheetIndex} 總計結果 (類型):`, typeof totalData, Array.isArray(totalData));
  
  // 根據資料計算總計（因為 Google Apps Script 的總計可能有問題）
  let calculatedIncome = 0;
  let calculatedExpense = 0;
  let incomeCount = 0;
  let expenseCount = 0;
  
  // 使用 Set 來追蹤已處理的記錄，避免重複計算
  const processedIncomeRecords = new Set();
  const processedExpenseRecords = new Set();
  
  if (data && typeof data === 'object') {
    // 獲取當前月份名稱（從 sheetNames 中查找，sheetIndex 是實際的 sheet 索引，需要減 2）
    const monthIndex = sheetIndex - 2;
    const currentMonthName = (monthIndex >= 0 && monthIndex < sheetNames.length) ? sheetNames[monthIndex] : '';
    console.log(`[loadMonthData] sheet=${sheetIndex}, monthIndex=${monthIndex}, 當前月份名稱: ${currentMonthName}`);
    console.log(`[loadMonthData] 所有資料 keys:`, Object.keys(data));
    
    Object.keys(data).forEach(key => {
      const rows = data[key] || [];
      const isIncome = key.includes('收入');
      const isExpense = key.includes('支出');
      
      // 只處理當前月份的資料（命名範圍名稱應該包含當前月份）
      const isCurrentMonth = currentMonthName && key.includes(currentMonthName);
      if (!isCurrentMonth && (isIncome || isExpense)) {
        console.warn(`[loadMonthData] 跳過非當前月份的資料: ${key} (期望包含: ${currentMonthName})`);
        return;
      }
      
      if (!isIncome && !isExpense) return; // 跳過不是收入或支出的資料
      
      console.log(`[loadMonthData] 處理資料: ${key}, ${rows.length} 行`);
      
      // 統計有效記錄數
      let validRowsCount = 0;
      
      rows.forEach((row, rowIndex) => {
        if (!row || row.length === 0) return;
        
        // 檢查是否為空行（所有欄位都是空）
        const isEmptyRow = row.every(cell => cell === '' || cell === null || cell === undefined);
        if (isEmptyRow) {
          return;
        }
        
        // 跳過總計行（第一欄是 "總計" 或空字串）
        const firstCell = row[0];
        if (firstCell === '總計' || firstCell === '' || firstCell === null || firstCell === undefined) {
          return;
        }
        
        // 檢查是否為有效記錄（第一欄應該是數字編號）
        const num = parseInt(firstCell, 10);
        if (!Number.isFinite(num) || num <= 0) {
          return;
        }
        
        // 檢查是否已經處理過這筆記錄（使用編號+時間作為唯一標識）
        const recordKey = `${num}_${row[1] || ''}`;
        if (isIncome) {
          if (processedIncomeRecords.has(recordKey)) {
            console.warn(`[loadMonthData] 跳過重複的收入記錄 #${num}`);
            return;
          }
          processedIncomeRecords.add(recordKey);
        } else if (isExpense) {
          if (processedExpenseRecords.has(recordKey)) {
            console.warn(`[loadMonthData] 跳過重複的支出記錄 #${num}`);
            return;
          }
          processedExpenseRecords.add(recordKey);
        }
        
        // 收入：[編號, 時間, item, cost, note] - cost 在索引 3 (D欄)
        // 支出：[編號, 時間, category, item, cost, note] - cost 在索引 4 (K欄，但在G-L範圍中是索引4)
        const costIndex = isIncome ? 3 : (isExpense ? 4 : -1);
        if (costIndex >= 0 && row[costIndex] !== undefined && row[costIndex] !== null && row[costIndex] !== '') {
          const cost = parseFloat(row[costIndex]);
          if (Number.isFinite(cost) && cost !== 0) { // 允許負數，但不累加0
            validRowsCount++;
            if (isIncome) {
              calculatedIncome += cost;
              incomeCount++;
              // 只在有效記錄數少於 20 時才輸出詳細日誌，避免控制台被刷屏
              if (incomeCount <= 20) {
                console.log(`[loadMonthData] 收入記錄 #${num}: cost=${cost}, 累計=${calculatedIncome}`);
              }
            } else if (isExpense) {
              calculatedExpense += cost;
              expenseCount++;
              // 只在有效記錄數少於 20 時才輸出詳細日誌，避免控制台被刷屏
              if (expenseCount <= 20) {
                console.log(`[loadMonthData] 支出記錄 #${num}: cost=${cost}, 累計=${calculatedExpense}`);
              }
            }
          }
        }
      });
      
      console.log(`[loadMonthData] ${key}: 總行數=${rows.length}, 有效記錄數=${validRowsCount}`);
    });
  }
  
  const calculatedTotal = calculatedIncome - calculatedExpense;
  const calculatedTotalData = [calculatedIncome, calculatedExpense, calculatedTotal];
  
  console.log(`[loadMonthData] sheet=${sheetIndex} 計算的總計:`, calculatedTotalData);
  console.log(`[loadMonthData] sheet=${sheetIndex} 收入記錄數: ${incomeCount}, 支出記錄數: ${expenseCount}`);
  console.log(`[loadMonthData] sheet=${sheetIndex} API 返回的總計:`, totalData);
  
  // 使用計算的總計，而不是 API 返回的總計
  return { data, total: calculatedTotalData };
};

// 預先載入所有月份的資料
const preloadAllMonthsData = async () => {
  if (sheetNames.length === 0) return;
  
  console.log('開始預先載入所有月份的資料...');
  console.log('sheetNames:', sheetNames);
  
  // 使用並發載入以提高速度
  const promises = sheetNames.map(async (name, idx) => {
    const sheetIndex = idx + 2; // 轉為實際 sheet index
    try {
      console.log(`[preloadAllMonthsData] 開始載入月份 ${name} (sheet ${sheetIndex})`);
      const monthData = await loadMonthData(sheetIndex);
      allMonthsData[sheetIndex] = monthData;
      // 調試：檢查載入的資料
      const totalPreview = Array.isArray(monthData.total) ? monthData.total : 'N/A';
      console.log(`[preloadAllMonthsData] 已載入月份 ${name} (sheet ${sheetIndex}): 總計=${totalPreview}`);
      return { sheetIndex, name, success: true };
    } catch (error) {
      console.error(`[preloadAllMonthsData] 載入月份 ${name} (sheet ${sheetIndex}) 失敗:`, error);
      return { sheetIndex, name, success: false, error };
    }
  });
  
  await Promise.all(promises);
  console.log('所有月份資料預載完成');
  console.log('allMonthsData keys:', Object.keys(allMonthsData));
  // 調試：顯示每個月份的總計
  Object.keys(allMonthsData).forEach(key => {
    const monthData = allMonthsData[key];
    const total = Array.isArray(monthData.total) ? monthData.total : 'N/A';
    console.log(`allMonthsData[${key}].total =`, total);
  });
};

// 從記憶體載入當前月份的資料（不發送請求）
const loadContentFromMemory = () => {
  // 先清空目前的記錄（確保不同月份的資料不會混在一起）
  allRecords = [];
  filteredRecords = [];
  currentRecordIndex = 0;

  // 驗證 currentSheetIndex 是否有效
  if (!Number.isFinite(currentSheetIndex) || currentSheetIndex < 2) {
    console.error('無效的 sheet 索引:', currentSheetIndex);
    currentSheetIndex = 2; // 預設為第三個分頁
  }

  // 從記憶體讀取資料
  const monthData = allMonthsData[currentSheetIndex];
  if (!monthData) {
    console.warn(`月份資料不存在 (sheet ${currentSheetIndex})，嘗試重新載入...`);
    console.log('可用的月份索引:', Object.keys(allMonthsData));
    return false; // 表示需要重新載入
  }

  // 調試：確認載入的資料
  const totalPreview = Array.isArray(monthData.total) ? monthData.total : 'N/A';
  console.log(`從記憶體載入月份 (sheet ${currentSheetIndex}): 總計=${totalPreview}`);

  // 處理資料（會自動過濾並顯示記錄）
  processDataFromResponse(monthData.data, true);
  
  // 更新總計
  updateTotalDisplay(monthData.total);
  
  // 確保顯示第一筆記錄（如果有的話，且不在新增模式）
  if (!isNewMode && filteredRecords.length > 0) {
    showRecord(0);
  }
  
  return true; // 表示成功從記憶體載入
};

// 載入當前月份的資料（優先從記憶體讀取，如果沒有則發送請求）
const loadContent = async (forceReload = false) => {
  // 如果不強制重新載入，先嘗試從記憶體讀取
  if (!forceReload && loadContentFromMemory()) {
    return; // 成功從記憶體載入，直接返回
  }

  // 如果記憶體中沒有資料，或需要強制重新載入，則發送請求
  try {
    const monthData = await loadMonthData(currentSheetIndex);
    
    // 更新記憶體中的資料
    allMonthsData[currentSheetIndex] = monthData;
    
    // 處理資料
    processDataFromResponse(monthData.data);
    
    // 更新總計
    updateTotalDisplay(monthData.total);
  } catch (error) {
    console.error('載入資料失敗:', error);
    throw error;
  }
};


const loadTotal = async () => {
  // 驗證 currentSheetIndex 是否有效
  if (!Number.isFinite(currentSheetIndex) || currentSheetIndex < 2) {
    console.error('無效的 sheet 索引:', currentSheetIndex);
    currentSheetIndex = 2; // 預設為第三個分頁
  }
  
  // 優先從記憶體讀取總計
  const monthData = allMonthsData[currentSheetIndex];
  if (monthData && monthData.total) {
    updateTotalDisplay(monthData.total);
    return;
  }
  
  // 如果記憶體中沒有，則發送請求
  try {
    const TotalParams = { name: "Show Total", sheet: currentSheetIndex };
  const Totalurl = `${base}?${new URLSearchParams(TotalParams)}`;
    const Totalres = await fetch(Totalurl, {
      method: "GET",
      redirect: "follow",
      mode: "cors"
    });
    
    if (!Totalres.ok) {
      throw new Error(`載入總計失敗: HTTP ${Totalres.status} ${Totalres.statusText}`);
    }
    
  const Totaldata = await Totalres.json();
    
    // 更新記憶體中的總計（如果資料存在）
    if (allMonthsData[currentSheetIndex]) {
      allMonthsData[currentSheetIndex].total = Totaldata;
    } else {
      // 如果資料不存在，創建一個新的條目
      allMonthsData[currentSheetIndex] = { total: Totaldata };
    }
    
    updateTotalDisplay(Totaldata);
  } catch (error) {
    console.error('載入總計時發生錯誤:', error);
    // 不拋出錯誤，只記錄，避免影響其他功能
  }
};

const showSpinner = () => {
  const spinner = document.createElement('div');
  spinner.id = 'loading-spinner';
  spinner.innerHTML = `
    <div>
      <div class="spinner-circle"></div>
      <span>載入中...</span>
    </div>
  `;
  
  document.getElementsByClassName('post-content')[0].appendChild(spinner);
};

const hideSpinner = () => {
  const spinner = document.getElementById('loading-spinner');
  if (spinner) {
    spinner.remove();
  }
};

const createInputRow = (labelText, inputId, inputType = 'text') => {
  const row = document.createElement('div');
  row.className = 'input-row';
  
  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = inputId; // 關聯到 input
  
  const input = document.createElement('input');
  input.id = inputId;
  input.name = inputId; // 添加 name 屬性以支持自動填充
  input.type = inputType;
  
  row.appendChild(label);
  row.appendChild(input);
  return row;
};

const createSelectRow = (labelText, selectId, options) => {
  const row = document.createElement('div');
  row.className = 'select-row';
  
  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = selectId; // 關聯到 select
  
  const selectContainer = document.createElement('div');
  selectContainer.className = 'select-container';
  
  const selectDisplay = document.createElement('div');
  selectDisplay.className = 'select-display';
  
  const selectText = document.createElement('div');
  selectText.className = 'select-text';
  selectText.textContent = options[0].text;
  
  const selectArrow = document.createElement('div');
  selectArrow.className = 'select-arrow';
  selectArrow.textContent = '▼';
  
  selectDisplay.appendChild(selectText);
  selectDisplay.appendChild(selectArrow);
  
  const hiddenSelect = document.createElement('select');
  hiddenSelect.id = selectId;
  hiddenSelect.name = selectId; // 添加 name 屬性以支持自動填充
  hiddenSelect.style.display = 'none';
  hiddenSelect.value = options[0].value;
  
  const dropdown = document.createElement('div');
  dropdown.className = 'select-dropdown';
  
  options.forEach(opt => {
    const option = document.createElement('div');
    option.className = 'select-option';
    option.textContent = opt.text;
    option.dataset.value = opt.value;
    
    option.addEventListener('click', function() {
      selectText.textContent = opt.text;
      hiddenSelect.value = opt.value;
      dropdown.style.display = 'none';
      selectArrow.style.transform = 'rotate(0deg)';
      hiddenSelect.dispatchEvent(new Event('change'));
    });
    
    dropdown.appendChild(option);
    const hiddenOption = document.createElement('option');
    hiddenOption.value = opt.value;
    hiddenOption.textContent = opt.text;
    hiddenSelect.appendChild(hiddenOption);
  });
  
  selectDisplay.addEventListener('click', function(e) {
    e.stopPropagation();
    const isOpen = dropdown.style.display === 'block';
    dropdown.style.display = isOpen ? 'none' : 'block';
    selectArrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
  });
  
  document.addEventListener('click', function(e) {
    if (!selectContainer.contains(e.target)) {
      dropdown.style.display = 'none';
      selectArrow.style.transform = 'rotate(0deg)';
    }
  });
  
  selectContainer.appendChild(selectDisplay);
  selectContainer.appendChild(dropdown);
  selectContainer.appendChild(hiddenSelect);
  
  row.appendChild(label);
  row.appendChild(selectContainer);
  return row;
};

const updateDivVisibility = (forceType = null) => {
  // 如果提供了類型參數，使用它；否則嘗試從 DOM 獲取最新元素的值
  let categoryValue = forceType;
  if (categoryValue === null) {
    // 先嘗試從全局變數獲取
    if (typeof categorySelect !== 'undefined' && categorySelect.value) {
      categoryValue = categorySelect.value;
    } else {
      // 如果全局變數不可用，從 DOM 獲取最新元素
      const categorySelectElement = document.getElementById('category-select');
      if (categorySelectElement) {
        categoryValue = categorySelectElement.value;
      } else {
        categoryValue = '支出'; // 默認值
      }
    }
  }
  
  div2.innerHTML = '';
  div3.innerHTML = '';
  div4.innerHTML = '';
  
  if (categoryValue === '支出') {
    const categoryRow = createSelectRow('類別：', 'expense-category-select', EXPENSE_CATEGORY_OPTIONS);
    const costRow = createInputRow('金額：', 'cost-input', 'number');
    const noteRow = createInputRow('備註：', 'note-input');
    noteRow.style.marginBottom = '0px';
    
    div2.appendChild(categoryRow);
    div3.appendChild(costRow);
    div4.appendChild(noteRow);
    
    itemContainer.style.display = 'flex';
    div2.style.display = 'flex';
    div3.style.display = 'flex';
    div4.style.display = 'flex';
  } else if (categoryValue === '收入') {
    const costRow = createInputRow('金額：', 'cost-input', 'number');
    const noteRow = createInputRow('備註：', 'note-input');
    noteRow.style.marginBottom = '0px';
    
    div2.appendChild(costRow);
    div3.appendChild(noteRow);
    
    itemContainer.style.display = 'flex';
    div2.style.display = 'flex';
    div3.style.display = 'flex';
    div4.style.display = 'none';
  }
};

const saveData = async () => {
  const categoryValue = categorySelect.value;
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  const TotalParams = { name: "Show Total", sheet: currentSheetIndex };
  
  if (!itemInput || !costInput) {
    alert('請等待表單載入完成');
    return;
  }
  
  const item = itemInput.value.trim();
  const costValue = costInput.value.trim();
  const cost = parseFloat(costValue);
  const note = noteInput ? noteInput.value.trim() : '';
  
  if (!item) {
    alert('請輸入項目');
    return;
  }
  
  if (!costValue || isNaN(cost) || cost <= 0) {
    alert('請輸入有效金額');
    return;
  }
  
  let category = '';
  let range = 0;
  
  if (categoryValue === '支出') {
    const div2Display = window.getComputedStyle(div2).display;
    if (div2Display === 'none' || div2Display === '') {
      alert('請等待表單載入完成');
      return;
    }
    const categorySelectElement = document.getElementById('expense-category-select');
    if (!categorySelectElement) {
      alert('請等待表單載入完成');
      return;
    }
    if (!categorySelectElement.value) {
      alert('請選擇支出類別');
      return;
    }
    category = categorySelectElement.value;
    range = 0;
  } else {
    range = 1;
  }
  
  
  saveButton.textContent = '儲存中...';
  saveButton.disabled = true;
  saveButton.style.opacity = '0.6';
  saveButton.style.cursor = 'not-allowed';
  
  let alreadyReset = false; // 確保只在合適時機還原按鈕狀態
  try {
    const postData = {
      name: "Upsert Data",
      sheet: currentSheetIndex,
      range: range,
      item: item,
      cost: cost,
      note: note,
      
    };
    
    // 支出時（range === 0）必須發送 category
    if (range === 0) {
      postData.category = category;
    }
    
    // 如果不是新增模式，必須傳送 updateRow 參數來更新現有記錄
    // updateRow 是行號 = 編號 + 2（第一行是標題，資料從第二行開始）
    if (!isNewMode) {
      if (filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length) {
        const currentRecord = filteredRecords[currentRecordIndex];
        const recordNum = parseInt(currentRecord.row[0], 10);
        if (Number.isFinite(recordNum) && recordNum > 0) {
          postData.updateRow = recordNum + 2;
        } else {
          console.warn('無法取得記錄編號，無法更新');
          alert('無法更新記錄：找不到記錄編號');
          return;
        }
      } else {
        console.warn('無法取得目前記錄，無法更新');
        alert('無法更新記錄：找不到目前記錄');
        return;
      }
    }

    
    const response = await fetch(base, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      headers: {
        "Content-Type": "text/plain;charset=utf-8",
      },
      body: JSON.stringify(postData)
    });
    
    const responseText = await response.text();
    
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      console.error('無法解析響應為 JSON:', responseText);
      throw new Error('後端響應格式錯誤: ' + responseText);
    }
    
    if (response.ok && result.success) {
      // 記錄是否在新增模式
      const wasInNewMode = isNewMode;
      const savedType = categoryValue;
      // 記錄目前編輯的記錄編號（用於編輯模式）
      const savedRecordNumber = !wasInNewMode && filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length 
        ? parseInt(filteredRecords[currentRecordIndex].row[0], 10) 
        : null;
      
      alert('資料已成功儲存！');
      
      // 在重新載入前，先設定 currentRecordNumber（用於編輯模式）
      if (!wasInNewMode && savedRecordNumber !== null) {
        currentRecordNumber = savedRecordNumber;
      }
      
      // 如果 Apps Script 回傳了 data 和 total，直接使用，否則重新載入
      if (result.data && result.total) {
        // 更新記憶體中當前月份的資料
        allMonthsData[currentSheetIndex] = {
          data: result.data,
          total: result.total
        };
        
        // 記錄當前顯示的記錄編號（用於更新後重新定位）
        const currentDisplayedRecordNumber = !wasInNewMode && filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length
          ? parseInt(filteredRecords[currentRecordIndex].row[0], 10)
          : null;
        
        // 使用回傳的資料更新記錄和總計（不自動過濾，稍後手動過濾）
        processDataFromResponse(result.data, false);
        updateTotalDisplay(result.total);
        
        // 根據保存的類型重新過濾記錄
        const currentType = categorySelect ? categorySelect.value : savedType;
        filterRecordsByType(currentType);
        
        // 如果剛才在編輯模式，嘗試找到剛才編輯的記錄並定位
        if (!wasInNewMode && currentDisplayedRecordNumber !== null) {
          const recordIndex = filteredRecords.findIndex(r => {
            const num = parseInt(r.row[0], 10);
            return Number.isFinite(num) && num > 0 && num === currentDisplayedRecordNumber;
          });
          
          if (recordIndex >= 0) {
            currentRecordIndex = recordIndex;
            showRecord(recordIndex);
            updateArrowButtons();
          } else {
            // 如果找不到，顯示第一筆
            if (filteredRecords.length > 0) {
              currentRecordIndex = 0;
              showRecord(0);
              updateArrowButtons();
            }
          }
        } else {
          // 新增模式或找不到記錄時，重置索引
          currentRecordIndex = 0;
          if (filteredRecords.length > 0) {
            showRecord(0);
            updateArrowButtons();
          }
        }
      } else {
      // 重新載入記錄（避免快取，加入短延遲）
      try {
        await new Promise(r => setTimeout(r, 200));
        await loadContent();
        } catch (e) {
          console.warn('重新載入記錄失敗:', e);
        }
      }
        
        // 如果剛才在新增模式，自動進入下一個新增卡片
        if (wasInNewMode) {
          // 確保類型正確
          if (categorySelect && categorySelect.value !== savedType) {
            categorySelect.value = savedType;
            categorySelectText.textContent = savedType;
            filterRecordsByType(savedType);
          }
          
          // 等待過濾完成後，進入新增模式
          setTimeout(() => {
            // 計算下一個編號
            let nextNumber = 1;
            if (filteredRecords.length > 0) {
              const maxNum = Math.max(
                ...filteredRecords
                  .map(r => parseInt(r.row[0], 10))
                  .filter(n => Number.isFinite(n) && n > 0)
              );
              if (Number.isFinite(maxNum) && maxNum > 0) {
                nextNumber = maxNum + 1;
              }
            }
            
            // 進入新增模式
            isNewMode = true;
            currentRecordIndex = filteredRecords.length > 0 ? filteredRecords.length - 1 : 0;
            updateDeleteButton(); // 更新刪除按鈕顯示
            
            // 清空表單
            const itemInput = document.getElementById('item-input');
            const costInput = document.getElementById('cost-input');
            const noteInput = document.getElementById('note-input');
            if (itemInput) itemInput.value = '';
            if (costInput) costInput.value = '';
            if (noteInput) noteInput.value = '';
            
            // 更新編號顯示
            if (typeof recordNumber !== 'undefined') {
              recordNumber.textContent = `#${String(nextNumber).padStart(3, '0')}`;
              currentRecordNumber = nextNumber;
            }
            
            // 新增下一筆時，「資料時間」使用現在時間
            if (typeof recordDate !== 'undefined') {
              recordDate.textContent = getNowFormattedDateTime();
            }
            
            // 如果是支出，重置類別選擇
            if (savedType === '支出') {
              const categorySelectElement = document.getElementById('expense-category-select');
              if (categorySelectElement && categorySelectElement.options.length > 0) {
                categorySelectElement.value = categorySelectElement.options[0].value;
                const selectContainer = categorySelectElement.parentElement;
                if (selectContainer) {
                  const selectDisplay = selectContainer.querySelector('div');
                  if (selectDisplay) {
                    const selectText = selectDisplay.querySelector('div');
                    if (selectText) {
                      selectText.textContent = categorySelectElement.options[0].textContent;
                    }
                  }
                }
              }
            }
            
            updateArrowButtons();
          }, 100);
        } else {
          // 如果不是新增模式（編輯模式），重新顯示剛才編輯的記錄
          if (savedRecordNumber !== null) {
            // 等待過濾完成後，找到剛才編輯的記錄並顯示
            // 使用較長的延遲，確保 loadContent 和 filterRecordsByType 完成
            setTimeout(() => {
              const recordIndex = filteredRecords.findIndex(r => {
                const num = parseInt(r.row[0], 10);
                return Number.isFinite(num) && num > 0 && num === savedRecordNumber;
              });
              
              if (recordIndex >= 0) {
                currentRecordIndex = recordIndex;
                showRecord(recordIndex);
                updateArrowButtons();
              } else {
                // 如果找不到，顯示第一筆
                if (filteredRecords.length > 0) {
                  currentRecordIndex = 0;
                  showRecord(0);
                  updateArrowButtons();
                }
              }
            }, 300);
          } else {
            // 如果找不到記錄編號，顯示第一筆
            setTimeout(() => {
              if (filteredRecords.length > 0) {
                currentRecordIndex = 0;
                showRecord(0);
                updateArrowButtons();
              }
            }, 100);
          }
        }
      
      // 總計更新完成後，才還原按鈕狀態
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
      alreadyReset = true;
    } else {
      const errorMessage = result.message || result.error || '未知錯誤';
      console.error('後端返回錯誤:', {
        success: result.success,
        message: errorMessage,
        fullResult: result
      });
      alert('儲存失敗: ' + errorMessage);
      // 失敗時還原按鈕狀態
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
      alreadyReset = true;
    }
  } catch (error) {
    console.error('儲存失敗:', error);
    console.error('錯誤詳情:', {
      message: error.message,
      stack: error.stack,
      name: error.name
    });
    alert('儲存失敗: ' + error.message);
    // 例外時還原按鈕狀態
    saveButton.textContent = '儲存';
    saveButton.disabled = false;
    saveButton.style.opacity = '1';
    saveButton.style.cursor = 'pointer';
    alreadyReset = true;
  } finally {
    if (!alreadyReset) {
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
    }
  }
};
 

const totalContainer = document.createElement('div');
totalContainer.className = 'total-container';

const budgetCardsContainer = document.createElement('div');
budgetCardsContainer.className = 'budget-cards-container';

const headerInfo = document.createElement('div');
headerInfo.className = 'header-info';

const recordNumber = document.createElement('div');
recordNumber.id = 'record-number';
recordNumber.textContent = '#001';

const recordDate = document.createElement('div');
recordDate.id = 'record-date';
recordDate.textContent = ''; // 顯示每筆記錄的時間（例如試算表中的最後修正時間）

headerInfo.appendChild(recordNumber);
headerInfo.appendChild(recordDate);

// 將月份下拉選單放在頁面標題右側（例如「預算表」右邊）
document.addEventListener('DOMContentLoaded', () => {
  const titleEl = document.querySelector('.post-title');
  if (titleEl && monthSelectWrapper) {
    titleEl.appendChild(monthSelectWrapper);
  }
});

// 刪除按鈕（垃圾桶）
const deleteButton = document.createElement('button');
deleteButton.className = 'delete-button';
deleteButton.innerHTML = '🗑️';

// 刪除當前記錄的函數（可被按鈕和鍵盤調用）
const deleteCurrentRecord = async () => {
  // 新增模式不能刪除
  if (isNewMode) {
    alert('無法刪除：目前為新增模式');
    return;
  }
  
  // 確認刪除
  if (!confirm('確定要刪除這筆記錄嗎？')) {
    return;
  }
  
  if (!filteredRecords.length || currentRecordIndex >= filteredRecords.length) {
    alert('無法刪除：找不到目前記錄');
    return;
  }
  
  const currentRecord = filteredRecords[currentRecordIndex];
  const recordNum = parseInt(currentRecord.row[0], 10);
  const recordType = currentRecord.type;
  
  if (!Number.isFinite(recordNum) || recordNum <= 0) {
    alert('無法刪除：找不到記錄編號');
    return;
  }
  
  // 確定 rangeType (0=支出, 1=收入)
  const rangeType = recordType === '支出' ? 0 : 1;
  
  // 禁用按鈕
  deleteButton.disabled = true;
  
  try {
    const postData = {
      name: "Delete Data",
      sheet: currentSheetIndex,
      range: rangeType,
      number: recordNum.toString() // 確保是字串，因為 Google Apps Script 用字串比較
    };
    
    const response = await fetch(base, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      headers: {
        "Content-Type": "text/plain;charset=utf-8",
      },
      body: JSON.stringify(postData)
    });
    
    const responseText = await response.text();
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      throw new Error('後端響應格式錯誤: ' + responseText);
    }
    
    if (response.ok && result.success) {
      alert('記錄已成功刪除！');
      
      // 如果 Apps Script 回傳了 data 和 total，直接使用，否則重新載入
      if (result.data && result.total) {
        // 更新記憶體中當前月份的資料
        allMonthsData[currentSheetIndex] = {
          data: result.data,
          total: result.total
        };
        
        // 使用回傳的資料更新記錄和總計
        processDataFromResponse(result.data, false);
        updateTotalDisplay(result.total);
        
        // 根據當前類型重新過濾記錄
        const currentType = categorySelect ? categorySelect.value : recordType;
        filterRecordsByType(currentType);
      } else {
        // 重新載入記錄（並更新記憶體）
      await new Promise(r => setTimeout(r, 200));
        await loadContent(true); // 強制重新載入
      }
      
      // 刪除後，顯示第一筆（如果還有記錄）
      setTimeout(() => {
        if (filteredRecords.length > 0) {
          currentRecordIndex = 0;
          showRecord(0);
          updateArrowButtons();
        } else {
          // 沒有記錄時，進入新增模式
          isNewMode = true;
          updateDeleteButton(); // 更新刪除按鈕顯示
          const itemInput = document.getElementById('item-input');
          const costInput = document.getElementById('cost-input');
          const noteInput = document.getElementById('note-input');
          if (itemInput) itemInput.value = '';
          if (costInput) costInput.value = '';
          if (noteInput) noteInput.value = '';
          if (typeof recordNumber !== 'undefined') {
            recordNumber.textContent = '#新增';
          }
          // 新增模式無資料時，資料時間使用現在時間
          if (typeof recordDate !== 'undefined') {
            recordDate.textContent = getNowFormattedDateTime();
          }
          updateArrowButtons();
        }
      }, 100);
    } else {
      const errorMessage = result.message || result.error || '未知錯誤';
      alert('刪除失敗: ' + errorMessage);
    }
  } catch (error) {
    console.error('刪除失敗:', error);
    alert('刪除失敗: ' + error.message);
  } finally {
    // 還原按鈕狀態
    deleteButton.disabled = false;
  }
};

// 垃圾桶按鈕點擊事件
deleteButton.addEventListener('click', deleteCurrentRecord);

// 更新刪除按鈕顯示狀態
function updateDeleteButton() {
  // 新增模式時隱藏刪除按鈕
  if (isNewMode) {
    deleteButton.style.display = 'none';
  } else {
    deleteButton.style.display = 'flex';
  }
}

const leftArrow = document.createElement('button');
leftArrow.className = 'arrow-button left';
leftArrow.innerHTML = '‹';

const rightArrow = document.createElement('button');
rightArrow.className = 'arrow-button right';
rightArrow.innerHTML = '›';

// 左右鍵切換所有記錄
// 更新箭頭按鈕狀態
function updateArrowButtons() {
  if (!filteredRecords.length && !isNewMode) {
    leftArrow.style.display = 'none';
    rightArrow.style.display = 'none';
    return;
  }
  
  // 如果在第一筆記錄且不在新增模式，隱藏左箭頭
  if (currentRecordIndex === 0 && !isNewMode) {
    leftArrow.style.display = 'none';
  } else {
  leftArrow.style.display = 'flex';
  }
  
  rightArrow.style.display = 'flex';
  
  // 如果在新增模式或最後一筆，右箭頭變成加號
  if (isNewMode || currentRecordIndex === filteredRecords.length - 1) {
    rightArrow.innerHTML = '+';
    rightArrow.classList.add('plus');
  } else {
    rightArrow.innerHTML = '›';
    rightArrow.classList.remove('plus');
  }
}

// 切換到上一筆記錄
function goToPreviousRecord() {
  if (!filteredRecords.length) return;
  
  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length) {
    currentRecordIndex = filteredRecords.length - 1;
  }
  
  // 如果在新增模式，回到最後一筆記錄
  if (isNewMode) {
    currentRecordIndex = filteredRecords.length > 0 ? filteredRecords.length - 1 : 0;
    if (filteredRecords.length > 0) {
    showRecord(currentRecordIndex);
    }
    updateArrowButtons();
  } else {
    currentRecordIndex = Math.max(0, currentRecordIndex - 1);
    if (currentRecordIndex < filteredRecords.length) {
    showRecord(currentRecordIndex);
    }
    updateArrowButtons();
  }
}

// 切換到下一筆記錄或進入新增模式
function goToNextRecord() {
  if (!filteredRecords.length) return;
  
  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length) {
    currentRecordIndex = filteredRecords.length - 1;
  }
  
  // 如果在最後一筆或新增模式，進入新增模式
  if (currentRecordIndex === filteredRecords.length - 1 || isNewMode) {
    isNewMode = true; // 進入新增模式
    updateDeleteButton(); // 更新刪除按鈕顯示
    
    // 清空表單，準備新增
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    
    // 計算下一個編號（目前類型中最大的編號 + 1）
    let nextNumber = 1;
    if (filteredRecords.length > 0) {
      const maxNum = Math.max(
        ...filteredRecords
          .map(r => parseInt(r.row[0], 10))
          .filter(n => Number.isFinite(n) && n > 0)
      );
      if (Number.isFinite(maxNum) && maxNum > 0) {
        nextNumber = maxNum + 1;
      }
    }
    
    // 更新編號顯示為下一個編號（但尚未寫回試算表）
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = `#${String(nextNumber).padStart(3, '0')}`;
      currentRecordNumber = nextNumber; // 記錄新增模式的編號
    }
    
    // 新增模式的「資料時間」使用現在時間
    if (typeof recordDate !== 'undefined') {
      recordDate.textContent = getNowFormattedDateTime();
    }
    
    updateArrowButtons();
  } else {
    currentRecordIndex = Math.min(filteredRecords.length - 1, currentRecordIndex + 1);
    showRecord(currentRecordIndex);
    updateArrowButtons();
  }
}

// 箭頭按鈕事件
leftArrow.addEventListener('click', goToPreviousRecord);
rightArrow.addEventListener('click', goToNextRecord);

// 切換收入/支出類型
function switchType(targetType) {
    // 確保 categorySelect 元素存在
    const categorySelectElement = document.getElementById('category-select');
    if (!categorySelectElement) {
      return; // 如果元素不存在，直接返回
    }
    
    const currentType = categorySelectElement.value || '支出';
    
    // 如果目標類型與當前類型不同，則切換
    if (currentType !== targetType) {
      // 在非新增模式下，保存當前記錄編號，以便在目標類型中查找相同編號的記錄
      // 檢查是否為新增模式：如果 recordNumber 顯示 "#新增" 或沒有記錄，則為新增模式
      const isActuallyNewMode = isNewMode || 
        (typeof recordNumber !== 'undefined' && recordNumber.textContent.includes('新增')) ||
        (filteredRecords.length === 0);
      
      if (!isActuallyNewMode) {
        // 優先從當前記錄獲取編號
        if (filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length) {
          const currentRecord = filteredRecords[currentRecordIndex];
          const recordNum = parseInt(currentRecord.row[0], 10);
          if (Number.isFinite(recordNum) && recordNum > 0) {
            currentRecordNumber = recordNum; // 保存當前編號
          }
        }
        // 如果從記錄獲取失敗，嘗試從顯示的編號元素中讀取
        if (currentRecordNumber === null && typeof recordNumber !== 'undefined') {
          const recordNumText = recordNumber.textContent;
          const match = recordNumText.match(/#(\d+)/);
          if (match && match[1]) {
            const recordNum = parseInt(match[1], 10);
            if (Number.isFinite(recordNum) && recordNum > 0) {
              currentRecordNumber = recordNum;
            }
          }
        }
      }
      
      // 先更新全局變數，這樣 updateDivVisibility 才能讀取到正確的值
      if (typeof categorySelect !== 'undefined') {
        categorySelect.value = targetType;
      }
      
      // 更新 DOM 元素
      categorySelectElement.value = targetType;
      
      // 更新顯示文字
      const selectContainer = categorySelectElement.parentElement;
      if (selectContainer) {
        const selectDisplay = selectContainer.querySelector('div');
        if (selectDisplay) {
          const selectText = selectDisplay.querySelector('div');
          if (selectText) {
            selectText.textContent = targetType;
          }
        }
      }
      
      // 先更新 UI 元素顯示（特別是支出/收入的欄位切換）
      if (typeof updateDivVisibility === 'function') {
        updateDivVisibility();
      }
      
      // 然後過濾記錄並更新 UI（filterRecordsByType 會自動處理相同編號的查找）
      // 使用 setTimeout 確保 updateDivVisibility 完成後再執行
      setTimeout(() => {
      // updateDivVisibility 會重新創建 expense-category-select 元素，需要重新獲取並更新
      const newCategorySelectElement = document.getElementById('expense-category-select');
        if (newCategorySelectElement) {
          // 更新新創建的元素的值（如果目標類型是支出，設置第一個選項；如果是收入，不需要設置）
          if (targetType === '支出' && newCategorySelectElement.options.length > 0) {
            newCategorySelectElement.value = newCategorySelectElement.options[0].value;
            // 同步更新自訂下拉顯示文字
            const newSelectContainer = newCategorySelectElement.parentElement;
            if (newSelectContainer) {
              const newSelectDisplay = newSelectContainer.querySelector('div');
              if (newSelectDisplay) {
                const newSelectText = newSelectDisplay.querySelector('div');
                if (newSelectText) {
                  newSelectText.textContent = newCategorySelectElement.options[0].textContent;
                }
              }
            }
          }
          
          // 更新全局變數的 value 屬性（雖然元素已更換，但我們可以通過更新屬性來保持一致性）
          // 實際上，由於 categorySelect 是 const，我們需要確保後續代碼使用 getElementById 獲取最新元素
          // 但為了兼容性，我們也更新全局變數的 value（如果元素還存在的話）
          if (typeof categorySelect !== 'undefined' && categorySelect.parentNode) {
            categorySelect.value = targetType;
          }
        }
        
        if (typeof filterRecordsByType === 'function') {
          filterRecordsByType(targetType);
        }
        
        // 更新相關 UI 元素
        if (typeof updateArrowButtons === 'function') {
          updateArrowButtons();
        }
        if (typeof updateDeleteButton === 'function') {
          updateDeleteButton();
        }
      }, 200);
  }
}

// 鍵盤事件（電腦左右鍵切換記錄，上下鍵切換收入/支出，Delete鍵刪除記錄）
document.addEventListener('keydown', (e) => {
  // 如果正在輸入文字，不觸發切換（但Delete鍵除外，因為它本身就是用於刪除的）
  const activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
    // Delete鍵在輸入框中時，只刪除文字，不觸發記錄刪除
    if (e.key === 'Delete' || e.key === 'Backspace') {
      return;
    }
    return;
  }
  
  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    goToPreviousRecord();
  } else if (e.key === 'ArrowRight') {
    e.preventDefault();
    goToNextRecord();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    // 向上鍵 = 切換到收入
    switchType('收入');
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    // 向下鍵 = 切換到支出
    switchType('支出');
  } else if (e.key === 'Delete' || e.key === 'Backspace') {
    e.preventDefault();
    // Delete鍵或Backspace鍵 = 刪除當前記錄
    deleteCurrentRecord();
  }
});

// 觸摸滑動事件（手機左右滑動切換記錄，上下滑動切換收入/支出）
let touchStartX = 0;
let touchEndX = 0;
let touchStartY = 0;
let touchEndY = 0;
let isSwiping = false;
let swipeDirection = null; // 'horizontal' 或 'vertical'

budgetCardsContainer.addEventListener('touchstart', (e) => {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
  isSwiping = false;
  swipeDirection = null;
}, { passive: true });

budgetCardsContainer.addEventListener('touchmove', (e) => {
  // 如果已經確定了方向，直接處理
  if (swipeDirection === 'vertical') {
    // 如果是垂直滑動，阻止頁面滾動（只在事件可取消時）
    if (e.cancelable) {
      e.preventDefault();
    }
    return;
  }
  
  // 檢查是否為水平或垂直滑動
  const currentX = e.changedTouches[0].screenX;
  const currentY = e.changedTouches[0].screenY;
  const deltaX = Math.abs(currentX - touchStartX);
  const deltaY = Math.abs(currentY - touchStartY);
  
  // 如果移動距離足夠大（降低閾值以更早判斷），判斷滑動方向
  if (deltaX > 5 || deltaY > 5) {
    if (deltaX > deltaY && deltaX > 10) {
      // 水平滑動
      swipeDirection = 'horizontal';
      isSwiping = true;
    } else if (deltaY > deltaX && deltaY > 10) {
      // 垂直滑動 - 立即阻止頁面滾動
      swipeDirection = 'vertical';
      isSwiping = true;
      // 只在事件可取消時阻止頁面滾動
      if (e.cancelable) {
        e.preventDefault();
      }
    }
  }
}, { passive: false });

budgetCardsContainer.addEventListener('touchend', (e) => {
  touchEndX = e.changedTouches[0].screenX;
  touchEndY = e.changedTouches[0].screenY;
  
  // 保存滑動方向，因為 handleSwipe 需要使用它
  const currentSwipeDirection = swipeDirection;
  
  if (isSwiping && currentSwipeDirection) {
    handleSwipe(currentSwipeDirection);
  }
  
  isSwiping = false;
  swipeDirection = null;
}, { passive: true });

function handleSwipe(direction) {
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;
  
  // 根據已確定的滑動方向處理
  if (direction === 'horizontal') {
    // 處理水平滑動（水平距離大於 50px）
    if (Math.abs(deltaX) > 50) {
      if (deltaX > 0) {
        // 向右滑動 = 上一筆
        goToPreviousRecord();
      } else {
        // 向左滑動 = 下一筆
        goToNextRecord();
      }
    }
  } else if (direction === 'vertical') {
    // 處理垂直滑動（垂直距離大於 50px）
    if (Math.abs(deltaY) > 50) {
      if (deltaY > 0) {
        // 向下滑動 = 切換到支出
        switchType('支出');
      } else {
        // 向上滑動 = 切換到收入
        switchType('收入');
      }
    }
  }
}

const div1 = document.createElement('div');
div1.className = 'category-select-row';

const categoryLabel = document.createElement('label');
categoryLabel.className = 'category-select-label';
categoryLabel.textContent = '類別：';
categoryLabel.htmlFor = 'category-select'; // 關聯到 select

const categorySelectContainer = document.createElement('div');
categorySelectContainer.className = 'category-select-container';

const categorySelectDisplay = document.createElement('div');
categorySelectDisplay.className = 'category-select-display';

const categorySelectText = document.createElement('div');
categorySelectText.className = 'category-select-text';
categorySelectText.textContent = '支出';

const categorySelectArrow = document.createElement('div');
categorySelectArrow.className = 'category-select-arrow';
categorySelectArrow.textContent = '▼';

categorySelectDisplay.appendChild(categorySelectText);
categorySelectDisplay.appendChild(categorySelectArrow);

const categorySelect = document.createElement('select');
categorySelect.id = 'category-select'; // 添加 id 以支持 label 關聯
categorySelect.name = 'category-select'; // 添加 name 屬性以支持自動填充
categorySelect.style.display = 'none';
categorySelect.value = '支出';
const optionExpense = document.createElement('option');
optionExpense.value = '支出';
optionExpense.textContent = '支出';
const optionIncome = document.createElement('option');
optionIncome.value = '收入';
optionIncome.textContent = '收入';
categorySelect.appendChild(optionExpense);
categorySelect.appendChild(optionIncome);

const categoryDropdown = document.createElement('div');
categoryDropdown.className = 'category-dropdown';

const categoryOption1 = document.createElement('div');
categoryOption1.className = 'category-option';
categoryOption1.textContent = '支出';
categoryOption1.dataset.value = '支出';
categoryOption1.addEventListener('click', function() {
  categorySelectText.textContent = '支出';
  categorySelect.value = '支出';
  categoryDropdown.style.display = 'none';
  categorySelectArrow.style.transform = 'rotate(0deg)';
  categorySelect.dispatchEvent(new Event('change'));
});

const categoryOption2 = document.createElement('div');
categoryOption2.className = 'category-option';
categoryOption2.textContent = '收入';
categoryOption2.dataset.value = '收入';
categoryOption2.addEventListener('click', function() {
  categorySelectText.textContent = '收入';
  categorySelect.value = '收入';
  categoryDropdown.style.display = 'none';
  categorySelectArrow.style.transform = 'rotate(0deg)';
  categorySelect.dispatchEvent(new Event('change'));
});

categoryDropdown.appendChild(categoryOption1);
categoryDropdown.appendChild(categoryOption2);

categorySelectDisplay.addEventListener('click', function(e) {
  e.stopPropagation();
  const isOpen = categoryDropdown.style.display === 'block';
  categoryDropdown.style.display = isOpen ? 'none' : 'block';
  categorySelectArrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
});

document.addEventListener('click', function(e) {
  if (!categorySelectContainer.contains(e.target)) {
    categoryDropdown.style.display = 'none';
    categorySelectArrow.style.transform = 'rotate(0deg)';
  }
});

categorySelectContainer.appendChild(categorySelectDisplay);
categorySelectContainer.appendChild(categoryDropdown);
categorySelectContainer.appendChild(categorySelect);

const itemContainer = document.createElement('div');
itemContainer.className = 'item-container';
itemContainer.className = 'item-container';

const itemTitleInput = document.createElement('input');
itemTitleInput.id = 'item-input';
itemTitleInput.name = 'item-input'; // 添加 name 屬性以支持自動填充
itemTitleInput.type = 'text';
itemTitleInput.placeholder = '輸入項目名稱...';


itemContainer.appendChild(itemTitleInput);

const div2 = document.createElement('div');
div2.style.display = 'none';
const div3 = document.createElement('div');
div3.style.display = 'none';
const div4 = document.createElement('div');
div4.style.display = 'none';

const saveButton = document.createElement('button');
saveButton.textContent = '儲存';
saveButton.className = 'save-button';

const columnsContainer = document.createElement('div');
columnsContainer.className = 'columns-container';

const incomeColumn = document.createElement('div');
incomeColumn.className = 'income-column';

const incomeTitle = document.createElement('h3');
incomeTitle.className = 'income-title';
incomeTitle.textContent = '收入：';

const incomeAmount = document.createElement('div');
incomeAmount.className = 'income-amount';
incomeAmount.textContent = 0;

const expenseColumn = document.createElement('div');
expenseColumn.className = 'expense-column';

const expenseTitle = document.createElement('h3');
expenseTitle.className = 'expense-title';
expenseTitle.textContent = '支出：';

const expenseAmount = document.createElement('div');
expenseAmount.className = 'expense-amount';
expenseAmount.textContent = 0;

const totalColumn = document.createElement('div');
totalColumn.className = 'total-column';

const totalTitle = document.createElement('h3');
totalTitle.className = 'total-title';
totalTitle.textContent = '總計：';

const totalAmount = document.createElement('div');
totalAmount.className = 'total-amount';
totalAmount.textContent = 0;

const updateTotalColor = (value) => {
  const numValue = parseFloat(value) || 0;
  totalAmount.classList.remove('positive', 'negative');
  totalTitle.classList.remove('positive', 'negative');
  if (numValue > 0) {
    totalAmount.classList.add('positive');
    totalTitle.classList.add('positive');
  } else if (numValue < 0) {
    totalAmount.classList.add('negative');
    totalTitle.classList.add('negative');
  }
};

// 月份選擇下拉（置於圓餅圖上方）
let monthSelect = null;
const monthSelectWrapper = document.createElement('div');
monthSelectWrapper.className = 'month-select-wrapper';

const monthSelectLabel = document.createElement('span');
monthSelectLabel.className = 'month-select-label';
monthSelectLabel.textContent = '月份：';

monthSelect = document.createElement('select');
monthSelect.id = 'month-select';
monthSelect.name = 'month-select';
monthSelect.className = 'month-select';

monthSelectWrapper.appendChild(monthSelectLabel);
monthSelectWrapper.appendChild(monthSelect);

const pieChartContainer = document.createElement('div');
pieChartContainer.className = 'pie-chart-container';
const pieChartPlaceholder = document.createElement('div');
pieChartPlaceholder.className = 'pie-chart-placeholder';
pieChartPlaceholder.textContent = '圓餅圖區域';
pieChartPlaceholder.style.fontWeight = '500';
 

const contentContainer = document.createElement('div');
contentContainer.className = 'content-container';
contentContainer.style.display = 'flex';
contentContainer.style.flexDirection = 'row';
contentContainer.style.justifyContent = 'space-between';
contentContainer.style.alignItems = 'flex-start';
contentContainer.style.width = '100%';

const totalContentContainer = document.createElement('div');
totalContentContainer.className = 'total-content-container';
totalContentContainer.style.width = '45%';
totalContentContainer.style.display = 'flex';
totalContentContainer.style.flexDirection = 'column';
totalContentContainer.style.justifyContent = 'center';
totalContentContainer.style.alignItems = 'center';
totalContentContainer.style.paddingLeft = '0px';
totalContentContainer.style.paddingTop = '0px';

pieChartContainer.style.width = '50%';
pieChartContainer.style.height = 'auto';
pieChartContainer.style.margin = '0';
pieChartContainer.style.display = 'flex';
pieChartContainer.style.justifyContent = 'center';
pieChartContainer.style.alignItems = 'center';

const submitContainer = document.createElement('div');
submitContainer.style.width = '100%';
submitContainer.style.display = 'flex';
submitContainer.style.justifyContent = 'center';
submitContainer.style.padding = '0';

// 載入月份列表
async function loadMonthNames() {
  const params = { name: "Show Tab Name" };
  const url = `${base}?${new URLSearchParams(params)}&_t=${Date.now()}`;
  const res = await fetch(url, {
    method: "GET",
    redirect: "follow",
    mode: "cors",
    cache: "no-store"
  });
  
  if (!res.ok) {
    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
  }
  
  const data = await res.json();
  
  if (!Array.isArray(data) || data.length === 0) {
    console.warn('無法取得月份分頁名稱');
    return [];
  }
  
  sheetNames = data;
  console.log('[loadMonthNames] 月份列表:', sheetNames);
  return sheetNames;
}

// 初始化月份下拉選單
const initMonthSelect = async () => {
  if (!monthSelect) return;
  
  try {
    // 載入月份列表
    await loadMonthNames();
    
    if (sheetNames.length === 0) {
      console.warn('無法取得月份分頁名稱');
      return;
    }
    
    // 檢查當前月份是否已有表格，若沒有則請後端建立（支出表和預算表都需要）
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const currentMonthStr = `${year}${month}`;
    const hasCurrentMonth = sheetNames.includes(currentMonthStr);
    
    if (!hasCurrentMonth) {
      console.log('[initMonthSelect] 找不到當前月份表格，請求建立新分頁:', currentMonthStr);
      try {
        const createResult = await callAPI({ name: "Create Tab" });
        alert(createResult.message || `已建立新分頁：${currentMonthStr}`);
        // 重新載入月份列表
        await loadMonthNames();
        console.log('[initMonthSelect] 重新載入月份列表（建立新分頁後）:', sheetNames);
      } catch (createError) {
        console.error('[initMonthSelect] 建立新月份分頁失敗:', createError);
        alert('無法自動建立本月表格，請稍後再試或手動建立。');
      }
    }
    
    // 清空舊選項
    monthSelect.innerHTML = '';
    
    // 建立選項
    sheetNames.forEach((name, idx) => {
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = name;
      monthSelect.appendChild(opt);
    });
    
    // 選擇最接近當前月份的分頁
    const closestSheetIndex = findClosestMonth();
    currentSheetIndex = closestSheetIndex;
    const selectIndex = currentSheetIndex - 2;
    if (selectIndex >= 0 && selectIndex < sheetNames.length) {
      monthSelect.value = String(selectIndex);
    }
    
    console.log('[initMonthSelect] 初始化當前 sheetIndex:', currentSheetIndex);
    
    // 預載所有月份資料
    showSpinner();
    try {
      await preloadAllMonthsData();
      console.log('[initMonthSelect] 所有月份資料已預載完成');
      
      // 處理當月資料並更新顯示
      const monthData = allMonthsData[currentSheetIndex];
      if (monthData) {
        processDataFromResponse(monthData.data);
        updateTotalDisplay(monthData.total);
      }
    } catch (e) {
      console.error('預載資料失敗:', e);
    } finally {
      hideSpinner();
    }
    
    // 下拉選單變更時，切換月份（從記憶體讀取，不發送請求）
    monthSelect.addEventListener('change', () => {
      const idx = parseInt(monthSelect.value, 10);
      if (!Number.isFinite(idx) || idx < 0 || idx >= sheetNames.length) {
        console.error('無效的下拉選單索引:', idx);
        return;
      }
      const oldSheetIndex = currentSheetIndex;
      currentSheetIndex = idx + 2; // 轉為實際 sheet index（前兩個是「空白表」和「下拉選單」）
      const monthName = sheetNames[idx];
      console.log(`切換月份: ${monthName} (下拉選單索引=${idx}, sheet索引=${currentSheetIndex})`);
      
      // 切換月份時，離開新增模式並重置狀態
      isNewMode = false;
      currentRecordNumber = null;
      
      // 從記憶體載入資料（不發送請求）
      if (loadContentFromMemory()) {
        updateDeleteButton();
        updateArrowButtons();
        enterNewModeIfEmpty();
      } else {
        // 如果記憶體中沒有資料，則發送請求載入
        console.warn(`記憶體中沒有 ${monthName} 的資料，重新載入...`);
        showSpinner();
        loadContent(true).then(() => {
          updateDeleteButton();
          updateArrowButtons();
          enterNewModeIfEmpty();
        }).catch(e => {
          console.error('切換月份時載入失敗:', e);
        }).finally(() => {
          hideSpinner();
        });
      }
    });
    
    // 初始載入目前選擇的月份資料（從記憶體讀取）
    loadContentFromMemory();
    updateDeleteButton();
    updateArrowButtons();
  } catch (error) {
    console.error('初始化月份下拉選單失敗:', error);
    if (error.message && error.message.includes('CORS') || error.message && error.message.includes('fetch')) {
      alert('CORS 錯誤：無法連接到 Google Apps Script。\n\n請確認：\n1. Apps Script Web App 已部署為「Anyone」可存取\n2. 已重新部署 Apps Script（部署設定變更後需要重新部署）\n3. 檢查瀏覽器控制台以獲取詳細錯誤訊息');
    }
  }
};


totalContainer.appendChild(contentContainer);
  contentContainer.appendChild(totalContentContainer);
    totalContentContainer.appendChild(columnsContainer);
      columnsContainer.appendChild(incomeColumn);
        incomeColumn.appendChild(incomeTitle);
        incomeColumn.appendChild(incomeAmount);
      columnsContainer.appendChild(expenseColumn);
        expenseColumn.appendChild(expenseTitle);
        expenseColumn.appendChild(expenseAmount);
      columnsContainer.appendChild(totalColumn);
        totalColumn.appendChild(totalTitle);
        totalColumn.appendChild(totalAmount);
  contentContainer.appendChild(pieChartContainer);
    pieChartContainer.appendChild(pieChartPlaceholder);
budgetCardsContainer.appendChild(headerInfo);
budgetCardsContainer.appendChild(deleteButton);
budgetCardsContainer.appendChild(leftArrow);
budgetCardsContainer.appendChild(rightArrow);
budgetCardsContainer.appendChild(itemContainer);
budgetCardsContainer.appendChild(div1);
  div1.appendChild(categoryLabel);
  div1.appendChild(categorySelectContainer);
budgetCardsContainer.appendChild(div2);
budgetCardsContainer.appendChild(div3);
budgetCardsContainer.appendChild(div4);
budgetCardsContainer.appendChild(submitContainer);
  submitContainer.appendChild(saveButton);

categorySelect.addEventListener('change', () => {
  updateDivVisibility();
  if (allRecords.length > 0) {
    filterRecordsByType(categorySelect.value);
  }
});
updateDivVisibility();
saveButton.addEventListener('click', saveData);
saveButton.addEventListener('click', loadTotal);

document.addEventListener('DOMContentLoaded', async function() {
  document.getElementsByClassName('post-content')[0].appendChild(totalContainer);
  document.getElementsByClassName('post-content')[0].appendChild(budgetCardsContainer);

  showSpinner();
  
  try {
    // 非阻塞載入「下拉選單」sheet 的最新選項
    const refreshDropdowns = () => {
      loadDropdownOptions().then(() => {
        console.log('[預算頁] 下拉選單選項已從 sheet=1 更新');
        // 如果當前顯示的是支出類別，重新渲染
        const categorySelect = document.getElementById('category-select');
        if (categorySelect && categorySelect.value === '支出') {
          updateDivVisibility('支出');
        }
      }).catch(err => {
        console.error('[預算頁] 更新下拉選單失敗:', err);
      });
    };
    
    refreshDropdowns();

    // 監聽設定頁的更新通知（當設定頁更新下拉選單後，自動重新載入）
    window.addEventListener('storage', (e) => {
      if (e.key === 'dropdownUpdated') {
        console.log('[預算頁] 收到下拉選單更新通知，重新載入...');
        refreshDropdowns();
      }
    });
    
    // 也監聽同頁面的 storage 事件（因為 storage 事件只在其他標籤頁觸發）
    let lastUpdateTime = localStorage.getItem('dropdownUpdated');
    setInterval(() => {
      const current = localStorage.getItem('dropdownUpdated');
      if (current && current !== lastUpdateTime) {
        lastUpdateTime = current;
        console.log('[預算頁] 檢測到下拉選單更新，重新載入...');
        refreshDropdowns();
      }
    }, 1000); // 每秒檢查一次

    await initMonthSelect(); // 先載入月份清單並載入對應月份資料
    updateDeleteButton(); // 初始化刪除按鈕顯示狀態
  } catch (error) {
    console.error('載入失敗:', error);
    const errorContainer = document.createElement('div');
    errorContainer.innerHTML = '載入失敗: ' + error.message;
    errorContainer.style.color = 'red';
    errorContainer.style.marginTop = '20px';
    document.getElementsByClassName('post-content')[0].appendChild(errorContainer);
  } finally {
    hideSpinner();
  }
});

</script>