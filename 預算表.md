---
layout: page
title: 預算表
permalink: /budget_table/
---

<link rel="stylesheet" href="{{ '/assets/budget-table.css' | relative_url }}">

<div id="user-info"></div>

<script>

// Budget
const baseBudget = "https://script.google.com/macros/s/AKfycbxkOKU5YxZWP1XTCFCF7a62Ar71fUz4Qw7tjF3MvMGkLTt6QzzhGLnDsD7wVI_cgpAR/exec";

// ===== 全域狀態變數 =====
let currentSheetIndex = 2; // 目前選擇的試算表分頁索引（2 代表第三個分頁）
let sheetNames = []; // 所有月份分頁名稱（不含前兩個「空白表」、「下拉選單」）
let allMonthsData = {}; // 預先載入的所有月份資料（key: sheetIndex, value: { data, total }）
let allRecords = []; // 目前選擇月份的記錄（收入 + 支出）
let filteredRecords = []; // 目前類型過濾後的記錄
let currentRecordIndex = 0;
let isNewMode = false; // 是否在新增模式
let currentRecordNumber = null; // 目前顯示的記錄編號
let isSwitchingMonth = false; // 防止快速連續切換月份
let monthSelectChangeHandler = null; // 儲存月份選擇事件處理器，用於移除
let currentAbortController = null; // 用於取消正在進行的請求
let timeUpdateInterval = null; // 用於更新新增模式的時間

// ===== 下拉選單選項（從「下拉選單」sheet=1 載入）=====
let EXPENSE_CATEGORY_OPTIONS = [
  { value: '生活花費：食', text: '生活花費：食' },
  { value: '生活花費：衣與外貌', text: '生活花費：衣與外貌' },
  { value: '生活花費：住、居家裝修、衛生用品、次月繳納帳單', text: '生活花費：住、居家裝修、衛生用品、次月繳納帳單' },
  { value: '生活花費：行', text: '生活花費：行' },
  { value: '生活花費：育', text: '生活花費：育' },
  { value: '生活花費：樂', text: '生活花費：樂' },
  { value: '生活花費：健（醫療）', text: '生活花費：健（醫療）' },
  { value: '生活花費：帳單', text: '生活花費：帳單' },
  { value: '儲蓄：退休金、醫療預備金、過年紅包支出', text: '儲蓄：退休金、醫療預備金、過年紅包支出' },
  { value: '家人：過年紅包、紀念日', text: '家人：過年紅包、紀念日' }
];

// 從「下拉選單」sheet=1 載入最新選項
// API URL（支出表）
const baseExpense = "https://script.google.com/macros/s/AKfycbxpBh0QVSVTjylhh9cj7JG9d6aJi7L7y6pQPW88EbAsNtcd5ckucLagH8XpSAGa8IZt/exec";

async function loadDropdownOptions() {
  try {
    const params = { name: "Show Tab Data", sheet: 1, _t: Date.now() };
    const url = `${baseExpense}?${new URLSearchParams(params)}`;
    const res = await fetch(url, {
      method: "GET",
      redirect: "follow",
      mode: "cors",
      cache: "no-store"
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const responseData = await res.json();
    // 處理不同的資料格式
    let data = null;

    // 如果是陣列，直接使用
    if (Array.isArray(responseData)) {
      data = responseData;
    }
    // 如果是物件，可能是命名範圍的格式，嘗試找到第一個陣列值
    else if (typeof responseData === 'object' && responseData !== null) {
      // 尋找第一個值是陣列的鍵
      for (const key in responseData) {
        if (Array.isArray(responseData[key]) && responseData[key].length > 0) {
          data = responseData[key];
          break;
        }
      }
    }

    if (!data || !Array.isArray(data) || data.length === 0) {
      return;
    }

    const headerRow = data[0];
    // 找對應欄位（預算表使用「支出－項目」）
    const colCategory = findHeaderColumn(headerRow, ['支出－項目', '支出-項目', '消費類別', '類別']);
    const readColumn = (col) => {
      const arr = [];
      if (col < 0) return arr;
      const seen = new Set();
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (!row) continue;
        const raw = row[col];
        if (raw === undefined || raw === null) continue;
        const val = raw.toString().trim();
        if (!val || seen.has(val)) continue;
        seen.add(val);
        arr.push({ value: val, text: val });
      }
      return arr;
    };

    if (colCategory >= 0) {
      EXPENSE_CATEGORY_OPTIONS = readColumn(colCategory);
      // 如果當前顯示的是支出類別，重新渲染
      const categorySelect = document.getElementById('category-select');
      if (categorySelect && categorySelect.value === '支出') {
        // 保存當前選擇的值（如果有）
        const currentCategorySelect = document.getElementById('expense-category-select');
        const currentValue = currentCategorySelect ? currentCategorySelect.value : '';
        updateDivVisibility('支出');
        // 如果之前有選擇值，嘗試恢復
        if (currentValue) {
          setTimeout(() => {
            const newCategorySelect = document.getElementById('expense-category-select');
            if (newCategorySelect && newCategorySelect.querySelector(`option[value="${currentValue}"]`)) {
              newCategorySelect.value = currentValue;
              // 同步更新自訂下拉顯示文字
              const selectContainer = newCategorySelect.parentElement;
              if (selectContainer) {
                const selectDisplay = selectContainer.querySelector('.select-display');
                if (selectDisplay) {
                  const selectText = selectDisplay.querySelector('.select-text');
                  if (selectText) {
                    const selectedOpt = newCategorySelect.options[newCategorySelect.selectedIndex];
                    selectText.textContent = selectedOpt ? selectedOpt.textContent : '';
                  }
                }
              }
            }
          }, 100);
        }
      }
    } else {
    }

  } catch (err) {
  }
}

function findHeaderColumn(headerRow, keywords) {
  for (let c = 0; c < headerRow.length; c++) {
    const headerText = (headerRow[c] || '').toString().trim();
    if (!headerText) continue;
    if (keywords.some(k => headerText.includes(k))) return c;
  }
  return -1;
}

// ===== 統一的 API 調用函數 =====
async function callAPI(postData) {
  // 取消之前的請求（如果存在）
  if (currentAbortController) {
    currentAbortController.abort();
  }

  // 創建新的 AbortController
  currentAbortController = new AbortController();
  const signal = currentAbortController.signal;

  try {
    const response = await fetch(baseBudget, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      signal: signal, // 添加 abort signal
      body: JSON.stringify(postData)
    });

    const responseText = await response.text();
    if (!responseText || responseText.trim() === '') {
      currentAbortController = null;
      return { success: true, data: null, total: null };
    }

    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      currentAbortController = null;
      throw new Error('後端響應格式錯誤: ' + responseText.substring(0, 100));
    }

    if (!response.ok || !result.success) {
      currentAbortController = null;
      throw new Error(result.message || result.error || '操作失敗');
    }

    // 請求成功後，清除快取以確保下次載入時取得最新資料
    try {
      const storageKey = `budget_monthData_${currentSheetIndex}`;
      sessionStorage.removeItem(storageKey);
      delete allMonthsData[currentSheetIndex];
    } catch (e) {
      // 忽略錯誤
    }

    // 請求成功後，清除 AbortController
    currentAbortController = null;
    return result;
  } catch (error) {
    // 如果是取消請求，不拋出錯誤
    if (error.name === 'AbortError') {
      currentAbortController = null;
      throw new Error('請求已取消');
    }
    currentAbortController = null;
    throw error;
  }
}

// ===== 找到最接近的月份（當前月份或最新月份）=====
function findClosestMonth() {
  if (sheetNames.length === 0) return 2;

  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentMonthStr = `${currentYear}${String(currentMonth).padStart(2, '0')}`;

  const currentIndex = sheetNames.findIndex(name => name === currentMonthStr);
  if (currentIndex !== -1) {
    return currentIndex + 2;
  }

  return sheetNames.length + 1; // 最後一個月份的 sheetIndex
}

// ===== 如果沒有記錄，進入新增模式 =====
function enterNewModeIfEmpty() {
  if (filteredRecords.length > 0) return;

  const currentType = categorySelect ? categorySelect.value : '支出';
  let nextNumber = 1;
  const allRecordsOfType = allRecords.filter(r => r.type === currentType);
  if (allRecordsOfType.length > 0) {
    const maxNum = Math.max(
      ...allRecordsOfType
        .map(r => parseInt(r.row[0], 10))
        .filter(n => Number.isFinite(n) && n > 0)
    );
    if (Number.isFinite(maxNum) && maxNum > 0) {
      nextNumber = maxNum + 1;
    }
  }
  isNewMode = true;
  if (typeof recordNumber !== 'undefined') {
    recordNumber.textContent = ''; // 新增模式不顯示編號
    recordNumber.style.display = 'none'; // 隱藏編號
  }
  if (typeof recordDate !== 'undefined') {
    recordDate.textContent = getNowFormattedDateTime();
  }

  // 啟動時間更新定時器（每秒更新一次）
  if (timeUpdateInterval) {
    clearInterval(timeUpdateInterval);
  }
  timeUpdateInterval = setInterval(() => {
    if (isNewMode && typeof recordDate !== 'undefined') {
      recordDate.textContent = getNowFormattedDateTime();
    } else {
      // 不在新增模式時停止定時器
      if (timeUpdateInterval) {
        clearInterval(timeUpdateInterval);
        timeUpdateInterval = null;
      }
    }
  }, 1000);
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  if (itemInput) itemInput.value = '';
  if (costInput) costInput.value = '';
  if (noteInput) noteInput.value = '';
  updateDeleteButton();
  updateArrowButtons();
}

// 根據目前選擇的類型過濾記錄
function filterRecordsByType(type) {
  filteredRecords = allRecords.filter(r => r.type === type);

  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length && filteredRecords.length > 0) {
    currentRecordIndex = filteredRecords.length - 1;
  } else if (filteredRecords.length === 0) {
    currentRecordIndex = 0;
  }

  //  新增模式：切換收入 / 支出模式：重新計算該類型的下一個編號
  if (isNewMode) {
    // 計算新類型中最大的編號 + 1
    let nextNumber = 1;
    if (filteredRecords.length > 0) {
      const maxNum = Math.max(
        ...filteredRecords
          .map(r => parseInt(r.row[0], 10))
          .filter(n => Number.isFinite(n) && n > 0)
      );
      if (Number.isFinite(maxNum) && maxNum > 0) {
        nextNumber = maxNum + 1;
      }
    }

    // 新增模式不顯示編號
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = ''; // 新增模式不顯示編號
      recordNumber.style.display = 'none'; // 隱藏編號
    }

    // 清空表單，準備新增
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';

    // 如果是支出，重置類別選擇
    if (type === '支出') {
      const categorySelectElement = document.getElementById('expense-category-select');
      if (categorySelectElement && categorySelectElement.options.length > 0) {
        categorySelectElement.value = categorySelectElement.options[0].value;
        const selectContainer = categorySelectElement.parentElement;
        if (selectContainer) {
          const selectDisplay = selectContainer.querySelector('div');
          if (selectDisplay) {
            const selectText = selectDisplay.querySelector('div');
            if (selectText) {
              selectText.textContent = categorySelectElement.options[0].textContent;
            }
          }
        }
      }
    }

    updateArrowButtons();
    updateDeleteButton(); // 更新刪除按鈕顯示
    return;
  }

  // 嘗試找到相同編號的記錄
  if (currentRecordNumber !== null && filteredRecords.length > 0) {
    const sameNumberIndex = filteredRecords.findIndex(r => {
      const num = parseInt(r.row[0], 10);
      return Number.isFinite(num) && num > 0 && num === currentRecordNumber;
    });

    if (sameNumberIndex >= 0) {
      currentRecordIndex = sameNumberIndex;
      showRecord(sameNumberIndex);
      updateArrowButtons();
      return;
    }
  }

  // 如果找不到相同編號，顯示第一筆
  currentRecordIndex = 0;
  if (filteredRecords.length > 0) {
    showRecord(0);
  } else {
    // 沒有記錄時，清空表單並更新按鈕
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = ''; // 新增模式不顯示編號
      recordNumber.style.display = 'none'; // 隱藏編號
    }
    updateArrowButtons();
    updateDeleteButton(); // 更新刪除按鈕顯示
  }
}

// 取得現在時間並格式化為 YYYY/MM/DD HH:MM
function getNowFormattedDateTime() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  return `${year}/${month}/${day} ${hours}:${minutes}`;
}

// 將各種時間字串格式統一轉為 YYYY/MM/DD HH:MM
function formatRecordDateTime(raw) {
  if (!raw) return '';

  // 嘗試以 Date 解析（支援 ISO 例如 2025-11-30T12:34:56Z）
  const dt = new Date(raw);
  if (Number.isNaN(dt.getTime())) {
    // 解析失敗時，保留原字串（例如已經是 2025/11/30 12:34）
    return raw;
  }

  const year = dt.getFullYear();
  const month = String(dt.getMonth() + 1).padStart(2, '0');
  const day = String(dt.getDate()).padStart(2, '0');
  const hours = String(dt.getHours()).padStart(2, '0');
  const minutes = String(dt.getMinutes()).padStart(2, '0');
  return `${year}/${month}/${day} ${hours}:${minutes}`;
}

// 顯示第 index 筆記錄到卡片上的輸入欄位
function showRecord(index) {
  if (!filteredRecords.length) return;

  // 確保 index 在有效範圍內
  if (index < 0 || index >= filteredRecords.length) {
    index = Math.max(0, Math.min(index, filteredRecords.length - 1));
  }

  currentRecordIndex = index; // 更新當前索引
  const { type, row } = filteredRecords[index];
  isNewMode = false; // 顯示記錄時退出新增模式

  // 停止時間更新定時器
  if (timeUpdateInterval) {
    clearInterval(timeUpdateInterval);
    timeUpdateInterval = null;
  }

  updateDeleteButton(); // 更新刪除按鈕顯示

  // 更新左上角編號：只顯示該記錄自己的編號（row[0]），不顯示收入/支出
  if (typeof recordNumber !== 'undefined') {
    const num = parseInt(row[0], 10);
    const recordNum = Number.isFinite(num) && num > 0 ? num : (index + 1);
    recordNumber.textContent = `#${String(recordNum).padStart(3, '0')}`;
    currentRecordNumber = recordNum; // 記錄目前編號
  }

  // 更新右上角「資料時間」：使用每筆記錄的時間欄位（row[1]，通常為試算表中的時間 / 最後修正時間）
  if (typeof recordDate !== 'undefined') {
    recordDate.textContent = formatRecordDateTime(row[1] || '');
  }

  // 設定「支出 / 收入」大類（只改畫面，不觸發 change 事件，避免遞迴）
  if (typeof categorySelect !== 'undefined' && typeof categorySelectText !== 'undefined') {
    const value = type === '收入' || type === '支出' ? type : '支出';
    categorySelect.value = value;
    categorySelectText.textContent = value;
    // 直接更新欄位顯示
    if (typeof updateDivVisibility === 'function') {
      updateDivVisibility();
    }
  }

  // 等 div2 / div3 / div4 依據類別建立好之後再填資料
  // 使用較長的延遲，確保 updateDivVisibility 完成
  setTimeout(() => {
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');

    if (type === '支出') {
      // 支出：[編號, 時間, category, item, cost, note]
      const categorySelectElement = document.getElementById('expense-category-select');
      if (categorySelectElement) {
        categorySelectElement.value = row[2] || '';
        // 同步更新自訂下拉顯示文字（若存在）
        const selectContainer = categorySelectElement.parentElement;
        if (selectContainer) {
          const selectDisplay = selectContainer.querySelector('div');
          if (selectDisplay) {
            const selectText = selectDisplay.querySelector('div');
            if (selectText) {
              selectText.textContent = row[2] || '';
            }
          }
        }
      }
      if (itemInput) {
        itemInput.value = row[3] || '';
        // 確保值已設定（避免 placeholder 顯示）
        if (itemInput.value === '' && row[3]) {
          itemInput.value = row[3];
        }
      }
      // 確保金額正確顯示（轉換為數字再轉回字串，避免格式問題）
      if (costInput) {
        const costValue = row[4];
        if (costValue !== undefined && costValue !== null && costValue !== '') {
          const numCost = parseFloat(costValue);
          costInput.value = Number.isFinite(numCost) ? numCost.toString() : '';
        } else {
          costInput.value = '';
        }
      }
      if (noteInput) noteInput.value = row[5] || '';
    } else {
      // 收入：[編號, 時間, item, cost, note]
      if (itemInput) {
        itemInput.value = row[2] || '';
        // 確保值已設定（避免 placeholder 顯示）
        if (itemInput.value === '' && row[2]) {
          itemInput.value = row[2];
        }
      }
      // 確保金額正確顯示（轉換為數字再轉回字串，避免格式問題）
      if (costInput) {
        const costValue = row[3];
        if (costValue !== undefined && costValue !== null && costValue !== '') {
          const numCost = parseFloat(costValue);
          costInput.value = Number.isFinite(numCost) ? numCost.toString() : '';
        } else {
          costInput.value = '';
        }
      }
      if (noteInput) noteInput.value = row[4] || '';
    }

    // 更新箭頭按鈕狀態
    updateArrowButtons();
  }, 150);
}

// 處理從 Apps Script 回傳的資料（用於更新 allRecords）
const processDataFromResponse = (data, shouldFilter = true) => {
  // 先清空目前的記錄
  allRecords = [];

  if (!data) {
    console.warn('[預算表] processDataFromResponse: data 為空');
    return;
  }

  // 獲取當前月份名稱
  const monthIndex = currentSheetIndex - 2;
  const currentMonthName = (monthIndex >= 0 && monthIndex < sheetNames.length) ? sheetNames[monthIndex] : '';

  // 使用 Set 追蹤已處理的記錄，避免重複
  const processedRecords = new Set();
  let processedCount = 0;

  // 預算表只處理物件格式的資料（命名範圍格式）
  // 命名範圍：當月收入202506、當月支出預算202506
  // 預算格式：收入 [編號, 時間, item, cost, note] (5欄)，支出 [編號, 時間, category, item, cost, note] (6欄)
  if (data && typeof data === 'object' && !Array.isArray(data)) {
    // 處理物件格式的資料（命名範圍格式）
    Object.keys(data).forEach(key => {
      const rows = data[key] || [];

      const isIncome = key.includes('收入');
      const isExpense = key.includes('支出');
      const type = isIncome ? '收入' : (isExpense ? '支出' : '');

      if (!type) {
        return;
      }

      // 只處理當前月份的資料（命名範圍名稱應該包含當前月份）
      // 如果月份名稱存在，則必須匹配；如果不存在，則處理所有符合類型的資料（用於初始化）
      let isCurrentMonth = false;
      if (!currentMonthName || currentMonthName === '') {
        // 如果沒有月份名稱，處理所有符合類型的資料（可能是初始化階段）
        isCurrentMonth = true;
      } else {
        // 檢查 key 是否包含當前月份名稱
        isCurrentMonth = key.includes(currentMonthName);
        // 如果直接匹配失敗，嘗試檢查是否包含月份數字（例如 202506）
        if (!isCurrentMonth && currentMonthName.length >= 6) {
          // 嘗試提取月份數字部分（例如從 "202506" 提取 "202506"）
          const monthNum = currentMonthName.substring(0, 6); // 取前6位（YYYYMM）
          isCurrentMonth = key.includes(monthNum);
        }
        // 如果還是失敗，嘗試只匹配年份和月份（例如 "2025" + "06"）
        if (!isCurrentMonth && currentMonthName.length >= 6) {
          const year = currentMonthName.substring(0, 4);
          const month = currentMonthName.substring(4, 6);
          isCurrentMonth = key.includes(year) && key.includes(month);
        }
      }
      if (!isCurrentMonth) {
        return;
      }

      rows.forEach((row, rowIndex) => {
        if (!row || !Array.isArray(row) || row.length === 0) {
          return;
        }

        // 預算格式檢查：收入應該是5欄，支出應該是6欄
        // 但允許欄位數量稍微寬鬆（可能有些欄位為空）
        if (type === '收入' && row.length < 5) {
          return;
        }
        if (type === '支出' && row.length < 6) {
          return;
        }

        // 跳過標題行和總計行（更嚴格的檢查）
        const firstCell = String(row[0] || '').trim();
        const firstCellLower = firstCell.toLowerCase();
        // 檢查是否為標題行（包含常見的標題關鍵字）
        if (firstCellLower === '交易日期' || firstCellLower === '編號' || firstCellLower === '日期' ||
            firstCellLower === '時間' || firstCellLower === '總計' || firstCell === '' ||
            firstCellLower.includes('項目') || firstCellLower.includes('金額') ||
            firstCellLower.includes('備註') || firstCellLower.includes('類別')) {
          return;
        }

        // 檢查是否為有效記錄（第一欄應該是數字編號）
        const num = parseInt(row[0], 10);
        if (!Number.isFinite(num) || num <= 0) {
          return;
        }

        // 使用編號+時間作為唯一標識，避免重複
        const recordKey = `${type}_${num}_${row[1] || ''}`;
        if (processedRecords.has(recordKey)) {
          return;
        }
        processedRecords.add(recordKey);

        allRecords.push({ type, row });
        processedCount++;
      });
    });
  } else if (Array.isArray(data)) {
    // 如果資料是陣列格式，嘗試轉換為物件格式
    // 這種情況應該很少見，因為預算表使用命名範圍格式
    // 但為了健壯性，我們還是處理一下
    console.warn('[預算表] 收到陣列格式的資料，預期應該是物件格式（命名範圍）');
    // 可以嘗試將陣列轉換為物件，但需要知道資料結構
    // 暫時跳過，因為預算表應該總是返回物件格式
  } else {
    console.warn('[預算表] 收到未知格式的資料:', typeof data, data);
  }

  // 根據目前選擇的類型過濾記錄（預設顯示支出）
  if (shouldFilter) {
    const currentType = categorySelect ? categorySelect.value : '支出';
    filterRecordsByType(currentType);
  }
};

// 如果 totalData 為 null 或 undefined，則從當前記錄計算即時總計
const updateTotalDisplay = (totalData = null) => {
  let income = 0;
  let expense = 0;
  let total = 0;

  if (totalData && Array.isArray(totalData) && totalData.length >= 3) {
    // 使用後端返回的總計
    income = parseFloat(totalData[0]) || 0;
    expense = parseFloat(totalData[1]) || 0;
    total = parseFloat(totalData[2]) || 0;
  } else {
    // 從當前記錄計算即時總計
    const incomeRecords = allRecords.filter(r => r.type === '收入');
    const expenseRecords = allRecords.filter(r => r.type === '支出');

    // 計算收入總計
    income = incomeRecords.reduce((sum, r) => {
      if (!r || !r.row || !Array.isArray(r.row)) return sum;
      const cost = parseFloat(r.row[3] || 0) || 0; // 收入：row[3] 是金額
      return sum + cost;
    }, 0);

    // 計算支出總計
    expense = expenseRecords.reduce((sum, r) => {
      if (!r || !r.row || !Array.isArray(r.row)) return sum;
      const cost = parseFloat(r.row[4] || 0) || 0; // 支出：row[4] 是金額
      return sum + cost;
    }, 0);

    // 加上即時輸入的金額（如果有的話）
    const costInput = document.getElementById('cost-input');
    if (costInput && costInput.value) {
      const currentType = categorySelect ? categorySelect.value : '支出';
      const liveCost = parseFloat(costInput.value) || 0;
      if (currentType === '收入') {
        income += liveCost;
      } else {
        expense += liveCost;
      }
    }

    total = income - expense;
  }

  incomeAmount.textContent = income.toLocaleString('zh-TW');
  expenseAmount.textContent = expense.toLocaleString('zh-TW');
  totalAmount.textContent = total.toLocaleString('zh-TW');
  updateTotalColor(total);
};

// 載入單個月份的資料和總計
const loadMonthData = async (sheetIndex, useGlobalAbortController = true) => {
  // 驗證 sheetIndex 是否有效
  if (!Number.isFinite(sheetIndex) || sheetIndex < 2) {
    throw new Error(`無效的 sheet 索引: ${sheetIndex}`);
  }

  let signal;
  let abortController;

  if (useGlobalAbortController) {
    // 取消之前的請求（如果存在）
    if (currentAbortController) {
      currentAbortController.abort();
    }

    // 創建新的 AbortController
    currentAbortController = new AbortController();
    signal = currentAbortController.signal;
  } else {
    // 為預載入任務創建獨立的 AbortController
    abortController = new AbortController();
    signal = abortController.signal;
  }

  // 從試算表抓出「當月收入 / 支出」等資料 - 添加時間戳避免快取
  const monthIndex = sheetIndex - 2;
  const currentMonthName = (monthIndex >= 0 && monthIndex < sheetNames.length) ? sheetNames[monthIndex] : '';

  const dataParams = { name: "Show Tab Data", sheet: sheetIndex, _t: Date.now() };
  const dataUrl = `${baseBudget}?${new URLSearchParams(dataParams)}`;

  let data;
  try {
    const res = await fetch(dataUrl, {
      method: "GET",
      redirect: "follow",
      mode: "cors",
      cache: "no-store", // 強制不使用快取
      signal: signal // 添加 abort signal
    });

    if (!res.ok) {
      throw new Error(`載入資料失敗: HTTP ${res.status} ${res.statusText}`);
    }

    data = await res.json();

    // 如果資料是陣列格式，需要轉換成命名範圍格式
    if (Array.isArray(data)) {

      // 將陣列轉換為命名範圍格式
      // 預算格式：收入 [編號, 時間, item, cost, note] (5欄)
      //          支出 [編號, 時間, category, item, cost, note] (6欄)
      const convertedData = {};
      let incomeRows = [];
      let expenseRows = [];

      data.forEach((row, rowIndex) => {
        if (!row || !Array.isArray(row) || row.length === 0) return;

        // 跳過標題行和總計行
        const firstCell = String(row[0] || '').trim();
        if (firstCell === '交易日期' || firstCell === '編號' || firstCell === '總計' || firstCell === '') {
          return;
        }

        // 根據欄位數量判斷類型
        if (row.length === 5) {
          // 收入格式：[編號, 時間, item, cost, note]
          incomeRows.push(row);
        } else if (row.length === 6) {
          // 支出格式：[編號, 時間, category, item, cost, note]
          expenseRows.push(row);
        } else {
          // 其他格式（如10欄的支出記錄）跳過，因為預算表只需要預算資料
        }
      });

      // 轉換為命名範圍格式
      if (incomeRows.length > 0) {
        convertedData[`當月收入${currentMonthName}`] = incomeRows;
      }
      if (expenseRows.length > 0) {
        convertedData[`當月支出預算${currentMonthName}`] = expenseRows;
      }

      data = convertedData;
    } else {
      // 物件格式（命名範圍格式），檢查命名範圍是否存在
      const expectedIncomeKey = `當月收入${currentMonthName}`;
      const expectedExpenseKey = `當月支出預算${currentMonthName}`;
      const hasIncome = data.hasOwnProperty(expectedIncomeKey);
      const hasExpense = data.hasOwnProperty(expectedExpenseKey);
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error(`載入月份 ${currentMonthName} (sheetIndex: ${sheetIndex}) 被取消`);
    }
    throw error;
  }

  // 載入總計 - 添加時間戳避免快取
  const TotalParams = { name: "Show Total", sheet: sheetIndex, _t: Date.now() };
  const Totalurl = `${baseBudget}?${new URLSearchParams(TotalParams)}`;
  const Totalres = await fetch(Totalurl, {
    method: "GET",
    redirect: "follow",
    mode: "cors",
    cache: "no-store", // 強制不使用快取
    signal: signal // 添加 abort signal
  });

  if (!Totalres.ok) {
    throw new Error(`載入總計失敗: HTTP ${Totalres.status} ${Totalres.statusText}`);
  }

  const totalData = await Totalres.json();

  // 請求成功後，清除 AbortController（僅當使用全局 AbortController 時）
  if (useGlobalAbortController) {
    currentAbortController = null;
  }

  // 根據資料計算總計（因為 Google Apps Script 的總計可能有問題）
  let calculatedIncome = 0;
  let calculatedExpense = 0;
  let incomeCount = 0;
  let expenseCount = 0;

  // 使用 Set 來追蹤已處理的記錄，避免重複計算
  const processedIncomeRecords = new Set();
  const processedExpenseRecords = new Set();

  if (data && typeof data === 'object') {
    // 調試：檢查 202506 月份的資料過濾
    // 根據新的 Apps Script，數據格式是：
    // key 是命名範圍名稱（如 "當月收入202506"、"當月支出預算202506"）
    // value 是 2D 數組（已過濾空行）
    Object.keys(data).forEach(key => {
      const rows = data[key] || [];

      // 根據命名範圍名稱判斷類型
      // 命名範圍格式：當月收入202506 或 當月支出預算202506
      const isIncome = key.includes('收入');
      const isExpense = key.includes('支出');

      if (!isIncome && !isExpense) {
        return; // 跳過不是收入或支出的資料
      }

      // 只處理當前月份的資料（命名範圍名稱應該包含當前月份）
      const isCurrentMonth = currentMonthName && key.includes(currentMonthName);
      if (!isCurrentMonth) {
        return; // 跳過不是當前月份的資料
      }

      rows.forEach((row, rowIndex) => {
        // 確保 row 是陣列
        if (!row || !Array.isArray(row) || row.length === 0) return;

        // 檢查是否為空行（所有欄位都是空）
        const isEmptyRow = row.every(cell => cell === '' || cell === null || cell === undefined);
        if (isEmptyRow) {
          return;
        }

        // 跳過總計行和標題行（更嚴格的檢查）
        const firstCell = String(row[0] || '').trim();
        const firstCellLower = firstCell.toLowerCase();
        // 檢查是否為標題行或總計行
        if (firstCellLower === '交易日期' || firstCellLower === '總計' || firstCell === '' ||
            firstCell === null || firstCell === undefined ||
            firstCellLower.includes('項目') || firstCellLower.includes('金額') ||
            firstCellLower.includes('備註') || firstCellLower.includes('類別') ||
            firstCellLower === '編號' || firstCellLower === '日期' || firstCellLower === '時間') {
          return;
        }

        // 檢查是否為有效記錄（第一欄應該是數字編號）
        const num = parseInt(firstCell, 10);
        if (!Number.isFinite(num) || num <= 0) {
          return;
        }

        // 檢查是否已經處理過這筆記錄（使用編號+時間作為唯一標識）
        const recordKey = `${num}_${row[1] || ''}`;
        if (isIncome) {
          if (processedIncomeRecords.has(recordKey)) {
            return;
          }
          processedIncomeRecords.add(recordKey);
        } else if (isExpense) {
          if (processedExpenseRecords.has(recordKey)) {
            return;
          }
          processedExpenseRecords.add(recordKey);
        }

        // 收入：[編號, 時間, item, cost, note] - cost 在索引 3 (D欄)
        // 支出：[編號, 時間, category, item, cost, note] - cost 在索引 4 (K欄)
        const costIndex = isIncome ? 3 : (isExpense ? 4 : -1);
        if (costIndex >= 0 && row[costIndex] !== undefined && row[costIndex] !== null && row[costIndex] !== '') {
          const cost = parseFloat(row[costIndex]);
          if (Number.isFinite(cost) && cost !== 0) { // 允許負數，但不累加0
            if (isIncome) {
              calculatedIncome += cost;
              incomeCount++;
            } else if (isExpense) {
              calculatedExpense += cost;
              expenseCount++;
            }
          }
        }
      });
    });
  }

  const calculatedTotal = calculatedIncome - calculatedExpense;
  const calculatedTotalData = [calculatedIncome, calculatedExpense, calculatedTotal];

  // 直接保存原始資料，不需要轉換格式
  // Apps Script 返回的格式已經是標準格式（如 "當月收入202506"、"當月支出預算202506"）
  // 保存時保持原樣，讀取時根據月份名稱匹配即可

  // 使用 API 返回的總計（Google Apps Script 計算的總計是正確的）
  return { data, total: totalData };
};

// 預先載入其他月份的資料（按順序：先下一個月，然後倒推往前）
const preloadAllMonthsData = async (baseProgress = 2, totalProgress = 0) => {
  if (sheetNames.length === 0) {
    return;
  }

  // 找出當前月份在 sheetNames 中的索引
  const currentMonthIdx = sheetNames.findIndex((name, idx) => {
    const sheetIndex = idx + 2;
    return sheetIndex === currentSheetIndex;
  });

  if (currentMonthIdx === -1) {
    return;
  }

  // 構建載入順序：先下一個月（currentMonthIdx + 1），然後倒推往前（currentMonthIdx - 1, currentMonthIdx - 2, ...）
  const loadOrder = [];

  // 先加入下一個月及之後的月份（從 currentMonthIdx + 1 開始）
  for (let i = currentMonthIdx + 1; i < sheetNames.length; i++) {
    const sheetIndex = i + 2;
    if (!allMonthsData[sheetIndex]) {
      loadOrder.push({ idx: i, sheetIndex, name: sheetNames[i] });
    }
  }

  // 然後倒推往前加入之前的月份（從 currentMonthIdx - 1 開始）
  for (let i = currentMonthIdx - 1; i >= 0; i--) {
    const sheetIndex = i + 2;
    if (!allMonthsData[sheetIndex]) {
      loadOrder.push({ idx: i, sheetIndex, name: sheetNames[i] });
    }
  }

  if (loadOrder.length === 0) {
    return;
  }

  let loadedCount = 0;

  // 按順序載入（一個接一個，不是並發）
  for (const item of loadOrder) {
    // 先檢查是否已經有預先存取的資料
    if (allMonthsData[item.sheetIndex]) {
      loadedCount++;
      if (totalProgress > 0) {
        updateProgress(baseProgress + loadedCount, totalProgress, `載入月份 ${item.name}（從快取）`);
      }
      continue; // 跳過，使用已有的資料
    }

    try {
      // 使用獨立的 AbortController，避免與用戶操作衝突
      const monthData = await loadMonthData(item.sheetIndex, false);
      allMonthsData[item.sheetIndex] = monthData;

      // 保存到 sessionStorage
      try {
        const storageKey = `budget_monthData_${item.sheetIndex}`;
        sessionStorage.setItem(storageKey, JSON.stringify(monthData));
      } catch (e) {
        // sessionStorage 可能已滿或不可用，忽略錯誤
      }

      // 更新進度條
      loadedCount++;
      if (totalProgress > 0) {
        updateProgress(baseProgress + loadedCount, totalProgress, `載入月份 ${item.name}`);
      }

      // 如果遇到還沒完成的，就跳出（顯示進度條）
      // 這裡我們繼續載入，但進度條會持續更新
    } catch (error) {
      // 即使失敗也更新進度
      loadedCount++;
      if (totalProgress > 0) {
        updateProgress(baseProgress + loadedCount, totalProgress, `載入月份 ${item.name}`);
      }

      // 如果遇到錯誤，繼續載入下一個月份（不中斷）
    }
  }
};

// 從記憶體載入當前月份的資料（不發送請求）
const loadContentFromMemory = () => {
  // 先清空目前的記錄（確保不同月份的資料不會混在一起）
  allRecords = [];
  filteredRecords = [];
  currentRecordIndex = 0;

  // 驗證 currentSheetIndex 是否有效
  if (!Number.isFinite(currentSheetIndex) || currentSheetIndex < 2) {
    currentSheetIndex = 2; // 預設為第三個分頁
  }

  // 先從記憶體讀取資料
  let monthData = allMonthsData[currentSheetIndex];

  // 如果記憶體中沒有，嘗試從 sessionStorage 讀取
  if (!monthData) {
    try {
      const storageKey = `budget_monthData_${currentSheetIndex}`;
      const storedData = sessionStorage.getItem(storageKey);
      if (storedData) {
        monthData = JSON.parse(storedData);
        // 明確標記為從 sessionStorage 載入
        monthData._fromApi = false;
        // 同時載入到記憶體
        allMonthsData[currentSheetIndex] = monthData;
      }
    } catch (e) {
      // sessionStorage 可能不可用或數據損壞，忽略錯誤
    }
  }

  if (!monthData) {
    return false; // 表示需要重新載入
  }

  // 從儲存載入時，顯示 loading 並擋住頁首
  showSpinner(true);

  // 處理資料（會自動過濾並顯示記錄）
  if (monthData.data) {
    processDataFromResponse(monthData.data, true);

    // 處理資料後立即更新總計（確保總計自動計算）
    if (monthData.total && Array.isArray(monthData.total) && monthData.total.length >= 3) {
      updateTotalDisplay(monthData.total);
    } else {
      // 如果沒有總計或格式不正確，使用即時計算
      updateTotalDisplay();
    }
  } else {
    console.warn('[預算表] loadContentFromMemory: 從記憶體載入的資料缺少 data 欄位', monthData);
    allRecords = [];
    filteredRecords = [];
    // 即使沒有資料，也要更新總計（顯示為0）
    updateTotalDisplay();
  }

  // 確保顯示第一筆記錄（如果有的話，且不在新增模式）
  if (filteredRecords.length > 0) {
    showRecord(0);
    updateArrowButtons();
  } else {
    // 如果沒有記錄，進入新增模式
    enterNewModeIfEmpty();
    updateDeleteButton();
    updateArrowButtons();
  }

  // 載入完成後隱藏 spinner
  setTimeout(() => {
    hideSpinner();
  }, 100);

  return true; // 表示成功從記憶體載入
};

// 載入當前月份的資料（優先從記憶體讀取，如果沒有則發送請求）
const loadContent = async (forceReload = false) => {
  // 如果不強制重新載入，先嘗試從記憶體讀取
  if (!forceReload && loadContentFromMemory()) {
    return; // 成功從記憶體載入，直接返回
  }

  // 如果記憶體中沒有資料，或需要強制重新載入，則發送請求
  try {
    const monthData = await loadMonthData(currentSheetIndex);

    // 更新記憶體中的資料
    allMonthsData[currentSheetIndex] = monthData;

    // 保存到 sessionStorage
    try {
      const storageKey = `budget_monthData_${currentSheetIndex}`;
      sessionStorage.setItem(storageKey, JSON.stringify(monthData));
    } catch (e) {
      // sessionStorage 可能已滿或不可用，忽略錯誤
    }

    // 處理資料（會自動過濾並顯示記錄）
    if (monthData.data) {
      processDataFromResponse(monthData.data, true);

      // 處理資料後立即更新總計（確保總計自動計算）
      if (monthData.total && Array.isArray(monthData.total) && monthData.total.length >= 3) {
        updateTotalDisplay(monthData.total);
      } else {
        // 如果沒有總計或格式不正確，使用即時計算
        updateTotalDisplay();
      }
    } else {
      console.warn('[預算表] loadContent: 載入的資料缺少 data 欄位', monthData);
      allRecords = [];
      filteredRecords = [];
      // 即使沒有資料，也要更新總計（顯示為0）
      updateTotalDisplay();
    }

    // 確保顯示第一筆記錄（如果有的話，且不在新增模式）
    if (filteredRecords.length > 0) {
      showRecord(0);
      updateArrowButtons();
    } else {
      // 如果沒有記錄，進入新增模式
      enterNewModeIfEmpty();
      updateDeleteButton();
      updateArrowButtons();
    }
  } catch (error) {
    throw error;
  }
};


const loadTotal = async () => {
  // 驗證 currentSheetIndex 是否有效
  if (!Number.isFinite(currentSheetIndex) || currentSheetIndex < 2) {
    currentSheetIndex = 2; // 預設為第三個分頁
  }

  // 優先從記憶體讀取總計
  const monthData = allMonthsData[currentSheetIndex];
  if (monthData && monthData.total) {
    updateTotalDisplay(monthData.total);
    return;
  }

  // 如果記憶體中沒有，則發送請求
  try {
    const TotalParams = { name: "Show Total", sheet: currentSheetIndex };
  const Totalurl = `${baseBudget}?${new URLSearchParams(TotalParams)}`;
    const Totalres = await fetch(Totalurl, {
      method: "GET",
      redirect: "follow",
      mode: "cors"
    });

    if (!Totalres.ok) {
      throw new Error(`載入總計失敗: HTTP ${Totalres.status} ${Totalres.statusText}`);
    }

  const Totaldata = await Totalres.json();

    // 更新記憶體中的總計（如果資料存在）
    if (allMonthsData[currentSheetIndex]) {
      allMonthsData[currentSheetIndex].total = Totaldata;
    } else {
      // 如果資料不存在，創建一個新的條目
      allMonthsData[currentSheetIndex] = { total: Totaldata };
    }

    // 保存到 sessionStorage
    try {
      const storageKey = `budget_monthData_${currentSheetIndex}`;
      sessionStorage.setItem(storageKey, JSON.stringify(allMonthsData[currentSheetIndex]));
    } catch (e) {
      // sessionStorage 可能已滿或不可用，忽略錯誤
    }

    updateTotalDisplay(Totaldata);
  } catch (error) {
    // 不拋出錯誤，只記錄，避免影響其他功能
  }
};

// 進度條自動動畫的計時器
let progressAnimationTimer = null;
let progressAnimationStartTime = null;
let progressAnimationTarget = 99; // 自動動畫的目標百分比（99%）

// 更新進度條（實際進度，會覆蓋自動動畫）
const updateProgress = (current, total, text = '載入中...') => {
  const progressContainer = document.getElementById('loading-progress');
  if (!progressContainer) return;

  const percentage = total > 0 ? Math.min(99, Math.round((current / total) * 99)) : 0;
  const progressBar = progressContainer.querySelector('.progress-bar');

  if (progressBar) {
    progressBar.style.width = `${percentage}%`;
    progressAnimationTarget = percentage; // 更新目標，但不會超過99%
  }
};

// 啟動進度條自動動畫（10秒內從0%到99%）
const startProgressAnimation = () => {
  // 清除之前的動畫
  if (progressAnimationTimer) {
    clearInterval(progressAnimationTimer);
    progressAnimationTimer = null;
  }

  const progressContainer = document.getElementById('loading-progress');
  if (!progressContainer) return;

  const progressBar = progressContainer.querySelector('.progress-bar');
  if (!progressBar) return;

  progressAnimationStartTime = Date.now();
  const duration = 10000; // 10秒
  const startPercentage = 0;
  const endPercentage = 99;

  progressAnimationTimer = setInterval(() => {
    const elapsed = Date.now() - progressAnimationStartTime;
    const progress = Math.min(elapsed / duration, 1);
    const currentPercentage = startPercentage + (endPercentage - startPercentage) * progress;

    // 確保不超過實際進度目標
    const finalPercentage = Math.min(currentPercentage, progressAnimationTarget);

    progressBar.style.width = `${finalPercentage}%`;

    // 如果已經達到99%或超過，停止動畫
    if (progress >= 1 || finalPercentage >= 99) {
      clearInterval(progressAnimationTimer);
      progressAnimationTimer = null;
    }
  }, 16); // 約60fps
};

const showSpinner = (coverHeader = false) => {
  // 如果已經存在，先移除
  const existingOverlay = document.getElementById('loading-overlay');
  if (existingOverlay) {
    existingOverlay.remove();
  }

  // 創建全屏遮罩（根據 coverHeader 決定是否覆蓋頁首）
  const overlay = document.createElement('div');
  overlay.id = 'loading-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: ${coverHeader ? '0' : '60px'};
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    z-index: ${coverHeader ? '2000' : '1500'}; /* 如果覆蓋頁首，z-index 要高於頁首 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: not-allowed;
  `;

  const progressContainer = document.createElement('div');
  progressContainer.id = 'loading-progress';
  const wrapperDiv = document.createElement('div');
  wrapperDiv.style.cssText = 'width: 300px; text-align: center;';
  const progressText = document.createElement('div');
  progressText.textContent = '載入中...';
  progressText.style.cssText = 'font-size: 16px; margin-bottom: 15px; color: #333;';
  const bgDiv = document.createElement('div');
  bgDiv.style.cssText = 'width: 100%; height: 8px; background-color: #e0e0e0; border-radius: 4px; overflow: hidden;';
  const progressBar = document.createElement('div');
  progressBar.className = 'progress-bar';
  progressBar.style.width = '0%';
  bgDiv.appendChild(progressBar);
  wrapperDiv.appendChild(progressText);
  wrapperDiv.appendChild(bgDiv);
  progressContainer.appendChild(wrapperDiv);

  overlay.appendChild(progressContainer);
  document.body.appendChild(overlay);

  // 啟動自動進度條動畫（10秒內從0%到99%）
  setTimeout(() => {
    startProgressAnimation();
  }, 50);
};

const hideSpinner = () => {
  // 清除自動動畫計時器
  if (progressAnimationTimer) {
    clearInterval(progressAnimationTimer);
    progressAnimationTimer = null;
  }

  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    const progressContainer = document.getElementById('loading-progress');
    if (progressContainer) {
      const progressBar = progressContainer.querySelector('.progress-bar');
      // 先跳到100%，然後再移除
      if (progressBar) {
        progressBar.style.width = '100%';
      }
    }

    // 稍微延遲後移除遮罩，讓用戶看到100%
    setTimeout(() => {
      overlay.remove();
      const spinner = document.getElementById('loading-spinner');
      if (spinner) {
        spinner.remove();
      }
      const progress = document.getElementById('loading-progress');
      if (progress) {
        progress.remove();
      }
      // 重置目標百分比
      progressAnimationTarget = 99;
    }, 200);
  } else {
    const spinner = document.getElementById('loading-spinner');
    if (spinner) {
      spinner.remove();
    }
    const progress = document.getElementById('loading-progress');
    if (progress) {
      progress.remove();
    }
  }
};

const createInputRow = (labelText, inputId, inputType = 'text') => {
  const row = document.createElement('div');
  row.className = 'input-row';

  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = inputId; // 關聯到 input

  const input = document.createElement('input');
  input.id = inputId;
  input.name = inputId; // 添加 name 屬性以支持自動填充
  input.type = inputType;

  row.appendChild(label);
  row.appendChild(input);
  return row;
};

const createTextareaRow = (labelText, textareaId, rows = 3) => {
  const row = document.createElement('div');
  row.className = 'input-row';

  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = textareaId; // 關聯到 textarea

  const textarea = document.createElement('textarea');
  textarea.id = textareaId;
  textarea.name = textareaId; // 添加 name 屬性以支持自動填充
  textarea.rows = rows;

  row.appendChild(label);
  row.appendChild(textarea);
  return row;
};

const createSelectRow = (labelText, selectId, options) => {
  const row = document.createElement('div');
  row.className = 'select-row';

  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = selectId; // 關聯到 select

  const selectContainer = document.createElement('div');
  selectContainer.className = 'select-container';

  const selectDisplay = document.createElement('div');
  selectDisplay.className = 'select-display';

  const selectText = document.createElement('div');
  selectText.className = 'select-text';
  selectText.textContent = options[0].text;

  const selectArrow = document.createElement('div');
  selectArrow.className = 'select-arrow';
  selectArrow.textContent = '▼';

  selectDisplay.appendChild(selectText);
  selectDisplay.appendChild(selectArrow);

  const hiddenSelect = document.createElement('select');
  hiddenSelect.id = selectId;
  hiddenSelect.name = selectId; // 添加 name 屬性以支持自動填充
  hiddenSelect.style.display = 'none';
  hiddenSelect.value = options[0].value;

  const dropdown = document.createElement('div');
  dropdown.className = 'select-dropdown';

  options.forEach(opt => {
    const option = document.createElement('div');
    option.className = 'select-option';
    option.textContent = opt.text;
    option.dataset.value = opt.value;

    option.addEventListener('click', function() {
      selectText.textContent = opt.text;
      hiddenSelect.value = opt.value;
      dropdown.style.display = 'none';
      selectArrow.style.transform = 'rotate(0deg)';
      hiddenSelect.dispatchEvent(new Event('change'));
    });

    dropdown.appendChild(option);
    const hiddenOption = document.createElement('option');
    hiddenOption.value = opt.value;
    hiddenOption.textContent = opt.text;
    hiddenSelect.appendChild(hiddenOption);
  });

  selectDisplay.addEventListener('click', function(e) {
    e.stopPropagation();
    const isOpen = dropdown.style.display === 'block';
    dropdown.style.display = isOpen ? 'none' : 'block';
    selectArrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
  });

  document.addEventListener('click', function(e) {
    if (!selectContainer.contains(e.target)) {
      dropdown.style.display = 'none';
      selectArrow.style.transform = 'rotate(0deg)';
    }
  });

  selectContainer.appendChild(selectDisplay);
  selectContainer.appendChild(dropdown);
  selectContainer.appendChild(hiddenSelect);

  row.appendChild(label);
  row.appendChild(selectContainer);
  return row;
};

const updateDivVisibility = (forceType = null) => {
  // 如果提供了類型參數，使用它；否則嘗試從 DOM 獲取最新元素的值
  let categoryValue = forceType;
  if (categoryValue === null) {
    // 先嘗試從全局變數獲取
    if (typeof categorySelect !== 'undefined' && categorySelect.value) {
      categoryValue = categorySelect.value;
    } else {
      // 如果全局變數不可用，從 DOM 獲取最新元素
      const categorySelectElement = document.getElementById('category-select');
      if (categorySelectElement) {
        categoryValue = categorySelectElement.value;
      } else {
        categoryValue = '支出'; // 默認值
      }
    }
  }

  div2.innerHTML = '';
  div3.innerHTML = '';
  div4.innerHTML = '';

  if (categoryValue === '支出') {
    const categoryRow = createSelectRow('類別：', 'expense-category-select', EXPENSE_CATEGORY_OPTIONS);
    const costRow = createInputRow('金額：', 'cost-input', 'number');
    const noteRow = createTextareaRow('備註：', 'note-input', 3);
    noteRow.style.marginBottom = '0px';

    div2.appendChild(categoryRow);
    div3.appendChild(costRow);
    div4.appendChild(noteRow);

    itemContainer.style.display = 'flex';
    div2.style.display = 'flex';
    div3.style.display = 'flex';
    div4.style.display = 'flex';
  } else if (categoryValue === '收入') {
    const costRow = createInputRow('金額：', 'cost-input', 'number');
    const noteRow = createTextareaRow('備註：', 'note-input', 3);
    noteRow.style.marginBottom = '0px';

    div2.appendChild(costRow);
    div3.appendChild(noteRow);

    itemContainer.style.display = 'flex';
    div2.style.display = 'flex';
    div3.style.display = 'flex';
    div4.style.display = 'none';
  }

  // 為金額輸入欄位添加即時更新總計的監聽器
  setTimeout(() => {
    const costInput = document.getElementById('cost-input');
    if (costInput) {
      // 移除舊的監聽器（如果有的話），避免重複添加
      const newCostInput = costInput.cloneNode(true);
      costInput.parentNode.replaceChild(newCostInput, costInput);

      // 添加新的監聽器
      newCostInput.addEventListener('input', () => {
        updateTotalDisplay(); // 不傳參數，使用即時計算
      });
    }
  }, 100);
};

const saveData = async () => {
  const categoryValue = categorySelect.value;
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  const TotalParams = { name: "Show Total", sheet: currentSheetIndex };

  if (!itemInput || !costInput) {
    alert('請等待表單載入完成');
    return;
  }

  const item = itemInput.value.trim();
  const costValue = costInput.value.trim();
  const cost = parseFloat(costValue);
  const note = noteInput ? noteInput.value.trim() : '';

  if (!item) {
    alert('請輸入項目');
    return;
  }

  if (!costValue || isNaN(cost) || cost <= 0) {
    alert('請輸入有效金額');
    return;
  }

  let category = '';
  let range = 0;

  if (categoryValue === '支出') {
    const div2Display = window.getComputedStyle(div2).display;
    if (div2Display === 'none' || div2Display === '') {
      alert('請等待表單載入完成');
      return;
    }
    const categorySelectElement = document.getElementById('expense-category-select');
    if (!categorySelectElement) {
      alert('請等待表單載入完成');
      return;
    }
    if (!categorySelectElement.value) {
      alert('請選擇支出類別');
      return;
    }
    category = categorySelectElement.value;
    range = 0;
  } else {
    range = 1;
  }


  // 鎖定整個頁面，等待後端回傳
  showSpinner();
  saveButton.textContent = '儲存中...';
  saveButton.disabled = true;
  saveButton.style.opacity = '0.6';
  saveButton.style.cursor = 'not-allowed';

  // 禁用所有輸入和按鈕
  if (itemInput) itemInput.disabled = true;
  if (costInput) costInput.disabled = true;
  if (noteInput) noteInput.disabled = true;
  if (categorySelect) categorySelect.disabled = true;
  const expenseCategorySelect = document.getElementById('expense-category-select');
  if (expenseCategorySelect) expenseCategorySelect.disabled = true;
  leftArrow.disabled = true;
  rightArrow.disabled = true;
  deleteButton.disabled = true;
  if (monthSelect) monthSelect.disabled = true;

  let alreadyReset = false; // 確保只在合適時機還原按鈕狀態
  try {
    const postData = {
      name: "Upsert Data",
      sheet: currentSheetIndex,
      range: range,
      item: item,
      cost: cost,
      note: note,

    };

    // 支出時（range === 0）必須發送 category
    if (range === 0) {
      postData.category = category;
    }

    // 如果不是新增模式，必須傳送 updateRow 參數來更新現有記錄
    // updateRow 是行號 = 編號 + 2（第一行是標題，資料從第二行開始）
    if (!isNewMode) {
      if (filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length) {
        const currentRecord = filteredRecords[currentRecordIndex];
        const recordNum = parseInt(currentRecord.row[0], 10);
        if (Number.isFinite(recordNum) && recordNum > 0) {
          postData.updateRow = recordNum + 2;
        } else {
          alert('無法更新記錄：找不到記錄編號');
          return;
        }
      } else {
        alert('無法更新記錄：找不到目前記錄');
        return;
      }
    }


    const response = await fetch(baseBudget, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      headers: {
        "Content-Type": "text/plain;charset=utf-8",
      },
      body: JSON.stringify(postData)
    });

    const responseText = await response.text();

    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      throw new Error('後端響應格式錯誤: ' + responseText);
    }

    if (response.ok && result.success) {
      // 記錄是否在新增模式
      const wasInNewMode = isNewMode;
      const savedType = categoryValue;
      // 記錄目前編輯的記錄編號（用於編輯模式）
      const savedRecordNumber = !wasInNewMode && filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length
        ? parseInt(filteredRecords[currentRecordIndex].row[0], 10)
        : null;

      alert('資料已成功儲存！');

      // 在重新載入前，先設定 currentRecordNumber（用於編輯模式）
      if (!wasInNewMode && savedRecordNumber !== null) {
        currentRecordNumber = savedRecordNumber;
      }

      // 如果 Apps Script 回傳了 data 和 total，直接使用，否則重新載入
      if (result.data && result.total) {
        // 更新記憶體中當前月份的資料
        allMonthsData[currentSheetIndex] = {
          data: result.data,
          total: result.total
        };

        // 保存到 sessionStorage
        try {
          const storageKey = `budget_monthData_${currentSheetIndex}`;
          sessionStorage.setItem(storageKey, JSON.stringify(allMonthsData[currentSheetIndex]));
        } catch (e) {
          // sessionStorage 可能已滿或不可用，忽略錯誤
        }

        // 記錄當前顯示的記錄編號（用於更新後重新定位）
        const currentDisplayedRecordNumber = !wasInNewMode && filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length
          ? parseInt(filteredRecords[currentRecordIndex].row[0], 10)
          : null;

        // 使用回傳的資料更新記錄和總計（不自動過濾，稍後手動過濾）
        processDataFromResponse(result.data, false);

        // 確保總計正確更新（如果後端返回的總計格式正確）
        if (result.total && Array.isArray(result.total) && result.total.length >= 3) {
        updateTotalDisplay(result.total);
        } else {
          // 如果後端沒有返回總計或格式不正確，重新載入總計
          await loadTotal();
        }

        // 根據保存的類型重新過濾記錄
        const currentType = categorySelect ? categorySelect.value : savedType;
        filterRecordsByType(currentType);

        // 等待過濾完成
        await new Promise(r => setTimeout(r, 100));

        // 如果剛才在編輯模式，嘗試找到剛才編輯的記錄並定位
        if (!wasInNewMode && currentDisplayedRecordNumber !== null) {
          const recordIndex = filteredRecords.findIndex(r => {
            const num = parseInt(r.row[0], 10);
            return Number.isFinite(num) && num > 0 && num === currentDisplayedRecordNumber;
          });

          if (recordIndex >= 0) {
            currentRecordIndex = recordIndex;
            showRecord(recordIndex);
            updateArrowButtons();
          } else {
            // 如果找不到，顯示第一筆
            if (filteredRecords.length > 0) {
              currentRecordIndex = 0;
              showRecord(0);
              updateArrowButtons();
            }
          }
        } else if (wasInNewMode) {
          // 新增模式：找到最後一筆記錄（剛新增的）並顯示
          if (filteredRecords.length > 0) {
            // 找到最後一筆記錄（應該是最新新增的）
            const lastIndex = filteredRecords.length - 1;
            currentRecordIndex = lastIndex;
            showRecord(lastIndex);
            updateArrowButtons();
        } else {
            // 如果沒有記錄，進入新增模式
            currentRecordIndex = 0;
            enterNewModeIfEmpty();
            updateArrowButtons();
          }
        } else {
          // 編輯模式但找不到記錄時，顯示第一筆
          currentRecordIndex = 0;
          if (filteredRecords.length > 0) {
            showRecord(0);
            updateArrowButtons();
          }
        }
      } else {
      // 重新載入記錄（避免快取，加入短延遲）
      try {
        await new Promise(r => setTimeout(r, 200));
        await loadContent();
        } catch (e) {
        }
      }

        // 如果剛才在新增模式，顯示剛新增的記錄
        if (wasInNewMode) {
          // 確保類型正確
          if (categorySelect && categorySelect.value !== savedType) {
            categorySelect.value = savedType;
            categorySelectText.textContent = savedType;
            filterRecordsByType(savedType);
          }

          // 等待過濾完成後，找到並顯示剛新增的記錄
          setTimeout(() => {
            if (filteredRecords.length > 0) {
              // 找到最後一筆記錄（應該是最新新增的）
              const lastIndex = filteredRecords.length - 1;
              currentRecordIndex = lastIndex;
              showRecord(lastIndex);
            updateArrowButtons();
            } else {
              // 如果沒有記錄，進入新增模式
              enterNewModeIfEmpty();
              updateArrowButtons();
            }
          }, 150);
        } else {
          // 如果不是新增模式（編輯模式），重新顯示剛才編輯的記錄
          if (savedRecordNumber !== null) {
            // 等待過濾完成後，找到剛才編輯的記錄並顯示
            // 使用較長的延遲，確保 loadContent 和 filterRecordsByType 完成
            setTimeout(() => {
              const recordIndex = filteredRecords.findIndex(r => {
                const num = parseInt(r.row[0], 10);
                return Number.isFinite(num) && num > 0 && num === savedRecordNumber;
              });

              if (recordIndex >= 0) {
                currentRecordIndex = recordIndex;
                showRecord(recordIndex);
                updateArrowButtons();
              } else {
                // 如果找不到，顯示第一筆
                if (filteredRecords.length > 0) {
                  currentRecordIndex = 0;
                  showRecord(0);
                  updateArrowButtons();
                }
              }
            }, 300);
          } else {
            // 如果找不到記錄編號，顯示第一筆
            setTimeout(() => {
              if (filteredRecords.length > 0) {
                currentRecordIndex = 0;
                showRecord(0);
                updateArrowButtons();
              }
            }, 100);
          }
        }

      // 總計更新完成後，才還原按鈕狀態
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
      alreadyReset = true;
    } else {
      const errorMessage = result.message || result.error || '未知錯誤';
      alert('儲存失敗: ' + errorMessage);
      // 失敗時還原按鈕狀態
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
      alreadyReset = true;
    }
  } catch (error) {
    alert('儲存失敗: ' + error.message);
    // 例外時還原按鈕狀態
    saveButton.textContent = '儲存';
    saveButton.disabled = false;
    saveButton.style.opacity = '1';
    saveButton.style.cursor = 'pointer';
    alreadyReset = true;
  } finally {
    // 恢復所有按鈕和輸入
    hideSpinner();
    if (!alreadyReset) {
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
    }

    // 恢復所有輸入和按鈕
    if (itemInput) itemInput.disabled = false;
    if (costInput) costInput.disabled = false;
    if (noteInput) noteInput.disabled = false;
    if (categorySelect) categorySelect.disabled = false;
    const expenseCategorySelect = document.getElementById('expense-category-select');
    if (expenseCategorySelect) expenseCategorySelect.disabled = false;
    leftArrow.disabled = false;
    rightArrow.disabled = false;
    deleteButton.disabled = false;
    if (monthSelect) monthSelect.disabled = false;
  }
};


const totalContainer = document.createElement('div');
totalContainer.className = 'total-container';

const budgetCardsContainer = document.createElement('div');
budgetCardsContainer.className = 'budget-cards-container';

const headerInfo = document.createElement('div');
headerInfo.className = 'header-info';

const recordNumber = document.createElement('div');
recordNumber.id = 'record-number';
recordNumber.textContent = '#001';

const recordDate = document.createElement('div');
recordDate.id = 'record-date';
recordDate.textContent = ''; // 顯示每筆記錄的時間（例如試算表中的最後修正時間）

headerInfo.appendChild(recordNumber);
headerInfo.appendChild(recordDate);

// 將月份下拉選單放在頁面標題右側（例如「預算表」右邊）
document.addEventListener('DOMContentLoaded', () => {
  const titleEl = document.querySelector('.post-title');
  if (titleEl && monthSelectWrapper) {
    titleEl.appendChild(monthSelectWrapper);
  }
});

// 刪除按鈕
const deleteButton = document.createElement('button');
deleteButton.className = 'delete-button';
deleteButton.textContent = '刪除';
deleteButton.style.cssText = `
  width: 60px;
  padding: 4px 12px;
  border: 1px solid #dc3545;
  border-radius: 4px;
  background-color: #fff;
  color: #dc3545;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
`;
deleteButton.onmouseenter = () => {
  if (!deleteButton.disabled) {
    deleteButton.style.backgroundColor = '#dc3545';
    deleteButton.style.color = '#fff';
  }
};
deleteButton.onmouseleave = () => {
  if (!deleteButton.disabled) {
    deleteButton.style.backgroundColor = '#fff';
    deleteButton.style.color = '#dc3545';
  }
};

// 刪除當前記錄的函數（可被按鈕和鍵盤調用）
const deleteCurrentRecord = async () => {
  // 新增模式不能刪除
  if (isNewMode) {
    alert('無法刪除：目前為新增模式');
    return;
  }

  // 確認刪除
  if (!confirm('確定要刪除這筆記錄嗎？')) {
    return;
  }

  if (!filteredRecords.length || currentRecordIndex >= filteredRecords.length) {
    alert('無法刪除：找不到目前記錄');
    return;
  }

  const currentRecord = filteredRecords[currentRecordIndex];
  const recordNum = parseInt(currentRecord.row[0], 10);
  const recordType = currentRecord.type;

  if (!Number.isFinite(recordNum) || recordNum <= 0) {
    alert('無法刪除：找不到記錄編號');
    return;
  }

  // 確定 rangeType (0=支出, 1=收入)
  const rangeType = recordType === '支出' ? 0 : 1;

  // 鎖定整個頁面，等待後端回傳
  showSpinner();
  deleteButton.disabled = true;

  // 禁用所有輸入和按鈕
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  if (itemInput) itemInput.disabled = true;
  if (costInput) costInput.disabled = true;
  if (noteInput) noteInput.disabled = true;
  if (categorySelect) categorySelect.disabled = true;
  const expenseCategorySelect = document.getElementById('expense-category-select');
  if (expenseCategorySelect) expenseCategorySelect.disabled = true;
  leftArrow.disabled = true;
  rightArrow.disabled = true;
  saveButton.disabled = true;
  if (monthSelect) monthSelect.disabled = true;

  try {
    const postData = {
      name: "Delete Data",
      sheet: currentSheetIndex,
      range: rangeType,
      number: recordNum.toString() // 確保是字串，因為 Google Apps Script 用字串比較
    };

    const response = await fetch(baseBudget, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      headers: {
        "Content-Type": "text/plain;charset=utf-8",
      },
      body: JSON.stringify(postData)
    });

    const responseText = await response.text();
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      throw new Error('後端響應格式錯誤: ' + responseText);
    }

    if (response.ok && result.success) {
      alert('記錄已成功刪除！');

      // 如果 Apps Script 回傳了 data 和 total，直接使用，否則重新載入
      if (result.data && result.total) {
        // 更新記憶體中當前月份的資料
        allMonthsData[currentSheetIndex] = {
          data: result.data,
          total: result.total
        };

        // 保存到 sessionStorage
        try {
          const storageKey = `budget_monthData_${currentSheetIndex}`;
          sessionStorage.setItem(storageKey, JSON.stringify(allMonthsData[currentSheetIndex]));
        } catch (e) {
          // sessionStorage 可能已滿或不可用，忽略錯誤
        }

        // 使用回傳的資料更新記錄和總計
        processDataFromResponse(result.data, false);

        // 立即更新總計（在更新資料後立即更新）
        // 確保總計正確更新（如果後端返回的總計格式正確）
        if (result.total && Array.isArray(result.total) && result.total.length >= 3) {
          // 更新記憶體中的總計
          allMonthsData[currentSheetIndex].total = result.total;
        updateTotalDisplay(result.total);
        } else {
          // 如果後端沒有返回總計或格式不正確，先使用即時計算，然後嘗試重新載入
          updateTotalDisplay(); // 立即使用即時計算更新總計
          // 然後嘗試重新載入總計（非阻塞）
          loadTotal().catch(() => {
            // 如果載入失敗，保持使用即時計算的結果
          });
        }

        // 根據當前類型重新過濾記錄
        const currentType = categorySelect ? categorySelect.value : recordType;
        filterRecordsByType(currentType);

        // 等待過濾完成後再顯示記錄
        await new Promise(r => setTimeout(r, 100));
      } else {
        // 重新載入記錄（並更新記憶體）
      await new Promise(r => setTimeout(r, 200));
        await loadContent(true); // 強制重新載入
      }

      // 刪除後，顯示第一筆（如果還有記錄）
      await new Promise(r => setTimeout(r, 100));
        if (filteredRecords.length > 0) {
          currentRecordIndex = 0;
          showRecord(0);
          updateArrowButtons();
        } else {
          // 沒有記錄時，進入新增模式
          isNewMode = true;
          updateDeleteButton(); // 更新刪除按鈕顯示
          const itemInput = document.getElementById('item-input');
          const costInput = document.getElementById('cost-input');
          const noteInput = document.getElementById('note-input');
          if (itemInput) itemInput.value = '';
          if (costInput) costInput.value = '';
          if (noteInput) noteInput.value = '';
          if (typeof recordNumber !== 'undefined') {
          recordNumber.textContent = ''; // 新增模式不顯示編號
          recordNumber.style.display = 'none'; // 隱藏編號
          }
          // 新增模式無資料時，資料時間使用現在時間
          if (typeof recordDate !== 'undefined') {
          recordDate.value = getNowFormattedDateTime();
          }
          updateArrowButtons();
        }
    } else {
      const errorMessage = result.message || result.error || '未知錯誤';
      alert('刪除失敗: ' + errorMessage);
    }
  } catch (error) {
    alert('刪除失敗: ' + error.message);
  } finally {
    // 恢復所有按鈕和輸入
    hideSpinner();
    deleteButton.disabled = false;

    // 恢復所有輸入和按鈕
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.disabled = false;
    if (costInput) costInput.disabled = false;
    if (noteInput) noteInput.disabled = false;
    if (categorySelect) categorySelect.disabled = false;
    const expenseCategorySelect = document.getElementById('expense-category-select');
    if (expenseCategorySelect) expenseCategorySelect.disabled = false;
    leftArrow.disabled = false;
    rightArrow.disabled = false;
    saveButton.disabled = false;
    if (monthSelect) monthSelect.disabled = false;
  }
};

// 垃圾桶按鈕點擊事件
deleteButton.addEventListener('click', deleteCurrentRecord);

// 更新刪除按鈕顯示狀態
function updateDeleteButton() {
  // 新增模式時隱藏刪除按鈕
  if (isNewMode) {
    deleteButton.style.display = 'none';
  } else {
    deleteButton.style.display = 'flex';
  }
}

const leftArrow = document.createElement('button');
leftArrow.className = 'arrow-button left';
leftArrow.innerHTML = '‹';

const rightArrow = document.createElement('button');
rightArrow.className = 'arrow-button right';
rightArrow.innerHTML = '›';

// 左右鍵切換所有記錄
// 更新箭頭按鈕狀態
function updateArrowButtons() {
  // 如果沒有記錄且是新增模式，隱藏所有箭頭
  if (!filteredRecords.length && isNewMode) {
    leftArrow.style.display = 'none';
    rightArrow.style.display = 'none';
    return;
  }

  // 如果沒有記錄且不是新增模式，也隱藏所有箭頭
  if (!filteredRecords.length && !isNewMode) {
    leftArrow.style.display = 'none';
    rightArrow.style.display = 'none';
    return;
  }

  // 如果有記錄，正常顯示箭頭
  // 如果在新增模式，只顯示左箭頭，右邊加號隱藏
  if (isNewMode) {
    leftArrow.style.display = 'flex';
    leftArrow.innerHTML = '‹';
    leftArrow.classList.remove('plus');
    rightArrow.style.display = 'none';
  } else {
    // 如果在第一筆記錄，隱藏左箭頭
    if (currentRecordIndex === 0) {
    leftArrow.style.display = 'none';
  } else {
  leftArrow.style.display = 'flex';
      leftArrow.innerHTML = '‹';
      leftArrow.classList.remove('plus');
    }

    rightArrow.style.display = 'flex';

    // 如果在最後一筆，右箭頭變成加號
    if (currentRecordIndex === filteredRecords.length - 1) {
      rightArrow.innerHTML = '+';
      rightArrow.classList.add('plus');
    } else {
      rightArrow.innerHTML = '›';
      rightArrow.classList.remove('plus');
    }
  }
}

// 切換到上一筆記錄
function goToPreviousRecord() {
  // 如果在新增模式，返回到最後一筆記錄
  if (isNewMode && filteredRecords.length > 0) {
    currentRecordIndex = filteredRecords.length - 1;
    showRecord(currentRecordIndex);
    updateArrowButtons();
    return;
  }

  if (!filteredRecords.length) return;

  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length) {
    currentRecordIndex = filteredRecords.length - 1;
  }

    currentRecordIndex = Math.max(0, currentRecordIndex - 1);
    if (currentRecordIndex < filteredRecords.length) {
    showRecord(currentRecordIndex);
    }
    updateArrowButtons();
}

// 切換到下一筆記錄或進入新增模式
function goToNextRecord() {
  if (!filteredRecords.length) return;

  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length) {
    currentRecordIndex = filteredRecords.length - 1;
  }

  // 如果在最後一筆或新增模式，進入新增模式
  if (currentRecordIndex === filteredRecords.length - 1 || isNewMode) {
    isNewMode = true; // 進入新增模式
    updateDeleteButton(); // 更新刪除按鈕顯示

    // 清空表單，準備新增
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';

    // 計算下一個編號（目前類型中最大的編號 + 1）
    let nextNumber = 1;
    if (filteredRecords.length > 0) {
      const maxNum = Math.max(
        ...filteredRecords
          .map(r => parseInt(r.row[0], 10))
          .filter(n => Number.isFinite(n) && n > 0)
      );
      if (Number.isFinite(maxNum) && maxNum > 0) {
        nextNumber = maxNum + 1;
      }
    }

    // 新增模式不顯示編號
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = ''; // 新增模式不顯示編號
      recordNumber.style.display = 'none'; // 隱藏編號
    }

    // 新增模式的「資料時間」使用現在時間
    if (typeof recordDate !== 'undefined') {
      recordDate.textContent = getNowFormattedDateTime();
    }

    updateArrowButtons();
  } else {
    currentRecordIndex = Math.min(filteredRecords.length - 1, currentRecordIndex + 1);
    showRecord(currentRecordIndex);
    updateArrowButtons();
  }
}

// 箭頭按鈕事件
leftArrow.addEventListener('click', goToPreviousRecord);
rightArrow.addEventListener('click', goToNextRecord);

// 切換收入/支出類型
function switchType(targetType) {
    // 確保 categorySelect 元素存在
    const categorySelectElement = document.getElementById('category-select');
    if (!categorySelectElement) {
      return; // 如果元素不存在，直接返回
    }

    const currentType = categorySelectElement.value || '支出';

    // 如果目標類型與當前類型不同，則切換
    if (currentType !== targetType) {
      // 在非新增模式下，保存當前記錄編號，以便在目標類型中查找相同編號的記錄
      // 檢查是否為新增模式：如果 isNewMode 為 true 或沒有記錄，則為新增模式
      const isActuallyNewMode = isNewMode || (filteredRecords.length === 0);

      if (!isActuallyNewMode) {
        // 優先從當前記錄獲取編號
        if (filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length) {
          const currentRecord = filteredRecords[currentRecordIndex];
          const recordNum = parseInt(currentRecord.row[0], 10);
          if (Number.isFinite(recordNum) && recordNum > 0) {
            currentRecordNumber = recordNum; // 保存當前編號
          }
        }
        // 如果從記錄獲取失敗，嘗試從顯示的編號元素中讀取
        if (currentRecordNumber === null && typeof recordNumber !== 'undefined') {
          const recordNumText = recordNumber.textContent;
          const match = recordNumText.match(/#(\d+)/);
          if (match && match[1]) {
            const recordNum = parseInt(match[1], 10);
            if (Number.isFinite(recordNum) && recordNum > 0) {
              currentRecordNumber = recordNum;
            }
          }
        }
      }

      // 先更新全局變數，這樣 updateDivVisibility 才能讀取到正確的值
      if (typeof categorySelect !== 'undefined') {
        categorySelect.value = targetType;
      }

      // 更新 DOM 元素
      categorySelectElement.value = targetType;

      // 更新顯示文字
      const selectContainer = categorySelectElement.parentElement;
      if (selectContainer) {
        const selectDisplay = selectContainer.querySelector('div');
        if (selectDisplay) {
          const selectText = selectDisplay.querySelector('div');
          if (selectText) {
            selectText.textContent = targetType;
          }
        }
      }

      // 先更新 UI 元素顯示（特別是支出/收入的欄位切換）
      if (typeof updateDivVisibility === 'function') {
        updateDivVisibility();
      }

      // 然後過濾記錄並更新 UI（filterRecordsByType 會自動處理相同編號的查找）
      // 使用 setTimeout 確保 updateDivVisibility 完成後再執行
      setTimeout(() => {
      // updateDivVisibility 會重新創建 expense-category-select 元素，需要重新獲取並更新
      const newCategorySelectElement = document.getElementById('expense-category-select');
        if (newCategorySelectElement) {
          // 更新新創建的元素的值（如果目標類型是支出，設置第一個選項；如果是收入，不需要設置）
          if (targetType === '支出' && newCategorySelectElement.options.length > 0) {
            newCategorySelectElement.value = newCategorySelectElement.options[0].value;
            // 同步更新自訂下拉顯示文字
            const newSelectContainer = newCategorySelectElement.parentElement;
            if (newSelectContainer) {
              const newSelectDisplay = newSelectContainer.querySelector('div');
              if (newSelectDisplay) {
                const newSelectText = newSelectDisplay.querySelector('div');
                if (newSelectText) {
                  newSelectText.textContent = newCategorySelectElement.options[0].textContent;
                }
              }
            }
          }

          // 更新全局變數的 value 屬性（雖然元素已更換，但我們可以通過更新屬性來保持一致性）
          // 實際上，由於 categorySelect 是 const，我們需要確保後續代碼使用 getElementById 獲取最新元素
          // 但為了兼容性，我們也更新全局變數的 value（如果元素還存在的話）
          if (typeof categorySelect !== 'undefined' && categorySelect.parentNode) {
            categorySelect.value = targetType;
          }
        }

        if (typeof filterRecordsByType === 'function') {
          filterRecordsByType(targetType);
        }

        // 更新相關 UI 元素
        if (typeof updateArrowButtons === 'function') {
          updateArrowButtons();
        }
        if (typeof updateDeleteButton === 'function') {
          updateDeleteButton();
        }
      }, 200);
  }
}

// 鍵盤事件（電腦左右鍵切換記錄，上下鍵切換收入/支出，Delete鍵刪除記錄）
document.addEventListener('keydown', (e) => {
  // 如果正在輸入文字，不觸發切換（但Delete鍵除外，因為它本身就是用於刪除的）
  const activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
    // Delete鍵在輸入框中時，只刪除文字，不觸發記錄刪除
    if (e.key === 'Delete' || e.key === 'Backspace') {
      return;
    }
    return;
  }

  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    goToPreviousRecord();
  } else if (e.key === 'ArrowRight') {
    e.preventDefault();
    goToNextRecord();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    // 向上鍵 = 切換到收入
    switchType('收入');
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    // 向下鍵 = 切換到支出
    switchType('支出');
  } else if (e.key === 'Delete' || e.key === 'Backspace') {
    e.preventDefault();
    // Delete鍵或Backspace鍵 = 刪除當前記錄
    deleteCurrentRecord();
  }
});

// 觸摸滑動事件（手機左右滑動切換記錄）
let touchStartX = 0;
let touchEndX = 0;
let touchStartY = 0;
let touchEndY = 0;

budgetCardsContainer.addEventListener('touchstart', (e) => {
  touchStartX = e.changedTouches[0].screenX;
  touchStartY = e.changedTouches[0].screenY;
}, { passive: true });

budgetCardsContainer.addEventListener('touchend', (e) => {
  touchEndX = e.changedTouches[0].screenX;
  touchEndY = e.changedTouches[0].screenY;
  const deltaX = touchEndX - touchStartX;
  const deltaY = touchEndY - touchStartY;

  // 處理水平滑動（水平距離明顯大於垂直距離，且水平距離大於 50px）
  if (Math.abs(deltaX) > Math.abs(deltaY) * 2 && Math.abs(deltaX) > 50) {
    if (deltaX > 0) {
      // 向右滑動 = 上一筆
      goToPreviousRecord();
    } else {
      // 向左滑動 = 下一筆
      goToNextRecord();
    }
  }
}, { passive: true });

const div1 = document.createElement('div');
div1.className = 'category-select-row';

const categoryLabel = document.createElement('label');
categoryLabel.className = 'category-select-label';
categoryLabel.textContent = '類別：';
categoryLabel.htmlFor = 'category-select'; // 關聯到 select

const categorySelectContainer = document.createElement('div');
categorySelectContainer.className = 'category-select-container';

const categorySelectDisplay = document.createElement('div');
categorySelectDisplay.className = 'category-select-display';

const categorySelectText = document.createElement('div');
categorySelectText.className = 'category-select-text';
categorySelectText.textContent = '支出';

const categorySelectArrow = document.createElement('div');
categorySelectArrow.className = 'category-select-arrow';
categorySelectArrow.textContent = '▼';

categorySelectDisplay.appendChild(categorySelectText);
categorySelectDisplay.appendChild(categorySelectArrow);

const categorySelect = document.createElement('select');
categorySelect.id = 'category-select'; // 添加 id 以支持 label 關聯
categorySelect.name = 'category-select'; // 添加 name 屬性以支持自動填充
categorySelect.style.display = 'none';
categorySelect.value = '支出';
const optionExpense = document.createElement('option');
optionExpense.value = '支出';
optionExpense.textContent = '支出';
const optionIncome = document.createElement('option');
optionIncome.value = '收入';
optionIncome.textContent = '收入';
categorySelect.appendChild(optionExpense);
categorySelect.appendChild(optionIncome);

const categoryDropdown = document.createElement('div');
categoryDropdown.className = 'category-dropdown';

const categoryOption1 = document.createElement('div');
categoryOption1.className = 'category-option';
categoryOption1.textContent = '支出';
categoryOption1.dataset.value = '支出';
categoryOption1.addEventListener('click', function() {
  categorySelectText.textContent = '支出';
  categorySelect.value = '支出';
  categoryDropdown.style.display = 'none';
  categorySelectArrow.style.transform = 'rotate(0deg)';
  categorySelect.dispatchEvent(new Event('change'));
});

const categoryOption2 = document.createElement('div');
categoryOption2.className = 'category-option';
categoryOption2.textContent = '收入';
categoryOption2.dataset.value = '收入';
categoryOption2.addEventListener('click', function() {
  categorySelectText.textContent = '收入';
  categorySelect.value = '收入';
  categoryDropdown.style.display = 'none';
  categorySelectArrow.style.transform = 'rotate(0deg)';
  categorySelect.dispatchEvent(new Event('change'));
});

categoryDropdown.appendChild(categoryOption1);
categoryDropdown.appendChild(categoryOption2);

categorySelectDisplay.addEventListener('click', function(e) {
  e.stopPropagation();
  const isOpen = categoryDropdown.style.display === 'block';
  categoryDropdown.style.display = isOpen ? 'none' : 'block';
  categorySelectArrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
});

document.addEventListener('click', function(e) {
  if (!categorySelectContainer.contains(e.target)) {
    categoryDropdown.style.display = 'none';
    categorySelectArrow.style.transform = 'rotate(0deg)';
  }
});

categorySelectContainer.appendChild(categorySelectDisplay);
categorySelectContainer.appendChild(categoryDropdown);
categorySelectContainer.appendChild(categorySelect);

const itemContainer = document.createElement('div');
itemContainer.className = 'item-container';
itemContainer.className = 'item-container';

const itemTitleInput = document.createElement('input');
itemTitleInput.id = 'item-input';
itemTitleInput.name = 'item-input'; // 添加 name 屬性以支持自動填充
itemTitleInput.type = 'text';
itemTitleInput.placeholder = '輸入項目名稱...';


itemContainer.appendChild(itemTitleInput);

const div2 = document.createElement('div');
div2.style.display = 'none';
const div3 = document.createElement('div');
div3.style.display = 'none';
const div4 = document.createElement('div');
div4.style.display = 'none';

const saveButton = document.createElement('button');
saveButton.textContent = '儲存';
saveButton.className = 'save-button';

const columnsContainer = document.createElement('div');
columnsContainer.className = 'columns-container';

const incomeColumn = document.createElement('div');
incomeColumn.className = 'income-column';

const incomeTitle = document.createElement('h3');
incomeTitle.className = 'income-title';
incomeTitle.textContent = '收入：';

const incomeAmount = document.createElement('div');
incomeAmount.className = 'income-amount';
incomeAmount.textContent = 0;

const expenseColumn = document.createElement('div');
expenseColumn.className = 'expense-column';

const expenseTitle = document.createElement('h3');
expenseTitle.className = 'expense-title';
expenseTitle.textContent = '支出：';

const expenseAmount = document.createElement('div');
expenseAmount.className = 'expense-amount';
expenseAmount.textContent = 0;

const totalColumn = document.createElement('div');
totalColumn.className = 'total-column';

const totalTitle = document.createElement('h3');
totalTitle.className = 'total-title';
totalTitle.textContent = '總計：';

const totalAmount = document.createElement('div');
totalAmount.className = 'total-amount';
totalAmount.textContent = 0;

const updateTotalColor = (value) => {
  const numValue = parseFloat(value) || 0;
  totalAmount.classList.remove('positive', 'negative');
  totalTitle.classList.remove('positive', 'negative');
  if (numValue > 0) {
    totalAmount.classList.add('positive');
    totalTitle.classList.add('positive');
  } else if (numValue < 0) {
    totalAmount.classList.add('negative');
    totalTitle.classList.add('negative');
  }
};

// 月份選擇下拉
let monthSelect = null;
const monthSelectWrapper = document.createElement('div');
monthSelectWrapper.className = 'month-select-wrapper';

const monthSelectLabel = document.createElement('span');
monthSelectLabel.className = 'month-select-label';
monthSelectLabel.textContent = '月份：';

monthSelect = document.createElement('select');
monthSelect.id = 'month-select';
monthSelect.name = 'month-select';
monthSelect.className = 'month-select';

monthSelectWrapper.appendChild(monthSelectLabel);
monthSelectWrapper.appendChild(monthSelect);

const submitContainer = document.createElement('div');
submitContainer.style.width = '100%';
submitContainer.style.display = 'flex';
submitContainer.style.justifyContent = 'center';
submitContainer.style.padding = '0';

// 載入月份列表
async function loadMonthNames() {
    const params = { name: "Show Tab Name" };
  const url = `${baseBudget}?${new URLSearchParams(params)}&_t=${Date.now()}`;
  const res = await fetch(url, {
      method: "GET",
      redirect: "follow",
    mode: "cors",
    cache: "no-store"
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }

    const data = await res.json();

    if (!Array.isArray(data) || data.length === 0) {
    return [];
    }

    sheetNames = data;
  return sheetNames;
}

// 初始化月份下拉選單
const initMonthSelect = async () => {
  if (!monthSelect) return;

  // 先載入月份列表（如果還沒有載入）
  if (sheetNames.length === 0) {
    try {
      await loadMonthNames();
      // 保存到 sessionStorage
      try {
        sessionStorage.setItem('budget_sheetNames', JSON.stringify(sheetNames));
      } catch (e) {
        // sessionStorage 可能不可用，忽略錯誤
      }
    } catch (e) {
      console.warn('[預算表] 載入月份列表失敗:', e);
      // 如果載入失敗，嘗試從 sessionStorage 讀取
  try {
    const storedSheetNames = sessionStorage.getItem('budget_sheetNames');
    if (storedSheetNames) {
      sheetNames = JSON.parse(storedSheetNames);
    }
      } catch (e2) {
    // sessionStorage 可能不可用或數據損壞，忽略錯誤
      }
    }
  }

  try {
    // 直接推斷當前月份和下一個月，不等待表格名字列表
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;
    const currentMonthStr = `${currentYear}${String(currentMonth).padStart(2, '0')}`;

    // 計算下一個月
    let nextYear = currentYear;
    let nextMonth = currentMonth + 1;
    if (nextMonth > 12) {
      nextMonth = 1;
      nextYear = currentYear + 1;
    }
    const nextMonthStr = `${nextYear}${String(nextMonth).padStart(2, '0')}`;

    // 已知：202512在index=3，以此為參考點推算目標月份的索引
    // 計算月份差來推算索引
    const referenceYear = 2025;
    const referenceMonth = 12;
    const referenceIndex = 3;

    // 計算目標月份與參考月份的月份差
    const calculateMonthDiff = (targetYear, targetMonth) => {
      return (targetYear - referenceYear) * 12 + (targetMonth - referenceMonth);
    };

    // 先計算下一個月的索引
    const nextYearNum = parseInt(nextMonthStr.substring(0, 4));
    const nextMonthNum = parseInt(nextMonthStr.substring(4, 6));
    const nextMonthDiff = calculateMonthDiff(nextYearNum, nextMonthNum);
    const nextMonthIndex = referenceIndex + nextMonthDiff;

    // 再計算當前月份的索引
    const currentYearNum = parseInt(currentMonthStr.substring(0, 4));
    const currentMonthNum = parseInt(currentMonthStr.substring(4, 6));
    const currentMonthDiff = calculateMonthDiff(currentYearNum, currentMonthNum);
    const currentMonthIndex = referenceIndex + currentMonthDiff;

    let targetSheetIndex = null;
    let targetMonthName = null;

    // 先嘗試從 sessionStorage 載入所有月份的資料
    const monthsToCheck = [
      { index: nextMonthIndex, name: nextMonthStr },
      { index: currentMonthIndex, name: currentMonthStr }
    ];

    for (const { index, name } of monthsToCheck) {
      if (index < 2) continue;

      // 先檢查記憶體中是否有資料
      if (allMonthsData[index]) {
        const testData = allMonthsData[index];
        if (testData && testData.data) {
          const dataKeys = Object.keys(testData.data);
          const hasMonth = dataKeys.some(key => key.includes(name));
          if (hasMonth && !targetSheetIndex) {
            // 如果資料沒有明確標記來源，假設是從 API 載入的（保守處理）
            // 這樣可以避免錯誤地顯示 spinner
            if (testData._fromApi === undefined) {
              testData._fromApi = true;
            }
            targetSheetIndex = index;
            targetMonthName = name;
            break;
          }
        }
        continue; // 已有資料，跳過 API 請求
      }

      // 嘗試從 sessionStorage 讀取
      try {
        const storageKey = `budget_monthData_${index}`;
        const storedData = sessionStorage.getItem(storageKey);
        if (storedData) {
          const testData = JSON.parse(storedData);
          if (testData && testData.data) {
            const dataKeys = Object.keys(testData.data);
            const hasMonth = dataKeys.some(key => key.includes(name));
            if (hasMonth) {
              // 明確標記為從 sessionStorage 載入（不設置 _fromApi 或設置為 false）
              testData._fromApi = false;
              allMonthsData[index] = testData;
              if (!targetSheetIndex) {
                targetSheetIndex = index;
                targetMonthName = name;
                break; // 找到目標月份，停止檢查
              }
            }
          }
        }
      } catch (e) {
        // sessionStorage 可能不可用或數據損壞，忽略錯誤
      }
    }

    // 如果從快取找不到，才發送 API 請求
    // 優先嘗試下一個月（推算的索引）
    if (!targetSheetIndex && nextMonthIndex >= 2) {
      try {
        const testData = await loadMonthData(nextMonthIndex);

        if (testData && testData.data) {
          // 驗證返回的資料是否包含下一個月的命名範圍
          const dataKeys = Object.keys(testData.data);
          const hasNextMonth = dataKeys.some(key => key.includes(nextMonthStr));

          if (hasNextMonth) {
            targetSheetIndex = nextMonthIndex;
            targetMonthName = nextMonthStr;
            testData._fromApi = true; // 標記為從 API 載入
            allMonthsData[nextMonthIndex] = testData;

            // 保存到 sessionStorage
            try {
              const storageKey = `budget_monthData_${nextMonthIndex}`;
              sessionStorage.setItem(storageKey, JSON.stringify(testData));
            } catch (e) {
              // sessionStorage 可能已滿或不可用，忽略錯誤
            }
          }
        }
      } catch (e) {
      }
    }

    // 如果下一個月載入失敗，嘗試當前月份
    if (!targetSheetIndex && currentMonthIndex >= 2) {
      try {
        const testData = await loadMonthData(currentMonthIndex);

        if (testData && testData.data) {
          const dataKeys = Object.keys(testData.data);
          const hasCurrentMonth = dataKeys.some(key => key.includes(currentMonthStr));

          if (hasCurrentMonth) {
            targetSheetIndex = currentMonthIndex;
            targetMonthName = currentMonthStr;
            testData._fromApi = true; // 標記為從 API 載入
            allMonthsData[currentMonthIndex] = testData;

            // 保存到 sessionStorage
            try {
              const storageKey = `budget_monthData_${currentMonthIndex}`;
              sessionStorage.setItem(storageKey, JSON.stringify(testData));
            } catch (e) {
              // sessionStorage 可能已滿或不可用，忽略錯誤
            }
          }
        }
      } catch (e) {
      }
    }

    // 如果找到了目標月份，顯示它
    if (targetSheetIndex && targetMonthName) {
      currentSheetIndex = targetSheetIndex;
      const targetMonthData = allMonthsData[targetSheetIndex];

      // 檢查資料是否從 sessionStorage 載入（需要擋住頁首）
      // 只有當 _fromApi 明確為 false 時，才認為是從 sessionStorage 載入
      // 如果 _fromApi 為 undefined 或 true，則認為是從 API 載入（保守處理）
      const isFromStorage = allMonthsData[targetSheetIndex] &&
                            targetMonthData._fromApi === false; // 明確檢查是否為 false

      // 如果是從 sessionStorage 載入，先隱藏原來的 spinner，然後顯示擋住頁首的 spinner
      if (isFromStorage) {
        hideSpinner();
        showSpinner(true); // 擋住頁首
      }

      // 立即處理並顯示目標月份資料
      if (targetMonthData.data) {
        processDataFromResponse(targetMonthData.data, true);

        // 處理資料後立即更新總計（確保總計自動計算）
        if (targetMonthData.total && Array.isArray(targetMonthData.total) && targetMonthData.total.length >= 3) {
          updateTotalDisplay(targetMonthData.total);
        } else {
          // 如果沒有總計或格式不正確，使用即時計算
          updateTotalDisplay();
        }
      } else {
        console.warn('[預算表] 目標月份資料缺少 data 欄位');
        allRecords = [];
        filteredRecords = [];
        // 即使沒有資料，也要更新總計（顯示為0）
        updateTotalDisplay();
      }

      // 確保顯示第一筆記錄（如果有的話，且不在新增模式）
      if (filteredRecords.length > 0) {
        showRecord(0);
        updateArrowButtons();
      } else {
        // 如果沒有記錄，進入新增模式
      enterNewModeIfEmpty();
      }
      updateDeleteButton();

      // 如果是從 sessionStorage 載入，延遲隱藏 spinner（讓用戶看到載入過程）
      if (isFromStorage) {
        setTimeout(() => {
      hideSpinner();
        }, 100);
      } else {
        // 從 API 載入，立即關閉載入遮罩（不擋住頁首）
        hideSpinner();
      }

      // 直接用推算的方式填充下拉選單（限制最多到下一個月）
      monthSelect.innerHTML = '';
      const monthOptions = [];

      // 添加當前月份
      monthOptions.push({ name: currentMonthStr, index: currentMonthIndex });
      // 添加下一個月（如果不同）
      if (nextMonthStr !== currentMonthStr) {
        monthOptions.push({ name: nextMonthStr, index: nextMonthIndex });
      }

      // 建立選項（按時間順序排序）
      monthOptions.sort((a, b) => {
        const yearA = parseInt(a.name.substring(0, 4));
        const monthA = parseInt(a.name.substring(4, 6));
        const yearB = parseInt(b.name.substring(0, 4));
        const monthB = parseInt(b.name.substring(4, 6));
        if (yearA !== yearB) return yearA - yearB;
        return monthA - monthB;
      });

      monthOptions.forEach((option, idx) => {
        const opt = document.createElement('option');
        opt.value = String(option.index - 2); // 選項值為 sheetIndex - 2（對應到 sheetNames 的索引）
        opt.textContent = option.name;
        monthSelect.appendChild(opt);
      });

      // 設置當前選擇的月份
      if (targetSheetIndex >= 2) {
        const selectIndex = targetSheetIndex - 2;
        const foundOption = monthOptions.findIndex(opt => opt.index === targetSheetIndex);
        if (foundOption >= 0) {
          monthSelect.value = String(monthOptions[foundOption].index - 2);
        }
      }

      // 在背景載入完整月份列表並預載其他月份的資料
      loadMonthNames().then(() => {
        // 使用完整的月份列表更新下拉選單
        monthSelect.innerHTML = '';
        sheetNames.forEach((name, idx) => {
          const opt = document.createElement('option');
          opt.value = String(idx);
          opt.textContent = name;
          monthSelect.appendChild(opt);
        });

        // 更新月份選擇器顯示
        if (currentSheetIndex >= 2) {
          const selectIndex = currentSheetIndex - 2;
          if (selectIndex >= 0 && selectIndex < sheetNames.length) {
            monthSelect.value = String(selectIndex);
          }
        }

        // 開始在背景預載其他月份的資料
        preloadAllMonthsData(0, 0).then(() => {
        }).catch((error) => {
          // 背景預載失敗不影響用戶操作
        });
      }).catch((err) => {
        // 載入月份列表失敗不影響當前顯示
      });
    } else {
      // 如果都找不到，嘗試從記憶體讀取
      hideSpinner();
      if (loadContentFromMemory()) {
        enterNewModeIfEmpty();
        updateDeleteButton();
        updateArrowButtons();
      }
    }

    // 下拉選單變更時，切換月份（從記憶體讀取，不發送請求）
    // 先移除舊的事件監聽器（如果存在）
    if (monthSelectChangeHandler) {
      monthSelect.removeEventListener('change', monthSelectChangeHandler);
    }

    monthSelectChangeHandler = async () => {
      // 防止快速連續切換
      if (isSwitchingMonth) {
        return;
      }

      const idx = parseInt(monthSelect.value, 10);
      if (!Number.isFinite(idx) || idx < 0 || idx >= sheetNames.length) {
        return;
      }

      // 如果選擇的是當前月份，不需要切換
      const newSheetIndex = idx + 2;
      const monthName = sheetNames[idx];

      if (currentSheetIndex === newSheetIndex) {
        return;
      }

      isSwitchingMonth = true;
      const oldSheetIndex = currentSheetIndex;
      currentSheetIndex = newSheetIndex; // 轉為實際 sheet index（前兩個是「空白表」和「下拉選單」）

      // 切換月份時，離開新增模式並重置狀態
      isNewMode = false;
      currentRecordNumber = null;

          const itemInput = document.getElementById('item-input');
          const costInput = document.getElementById('cost-input');
          const noteInput = document.getElementById('note-input');
      const expenseCategorySelect = document.getElementById('expense-category-select');

      try {
        // 先嘗試從記憶體載入資料（不發送請求、不顯示載入動畫）
        if (loadContentFromMemory()) {
          // 從記憶體載入成功，立即更新 UI
          updateDeleteButton();
          updateArrowButtons();
          enterNewModeIfEmpty();
          isSwitchingMonth = false;
        } else {
          // 記憶體中沒有資料時，顯示進度條並載入
          showSpinner();

          try {
            // 載入該月份的資料
            const monthData = await loadMonthData(currentSheetIndex);
            allMonthsData[currentSheetIndex] = monthData;

            // 保存到 sessionStorage
            try {
              const storageKey = `budget_monthData_${currentSheetIndex}`;
              sessionStorage.setItem(storageKey, JSON.stringify(monthData));
            } catch (e) {
              // sessionStorage 可能已滿或不可用，忽略錯誤
            }

            // 處理並顯示資料
            processDataFromResponse(monthData.data);
            updateTotalDisplay(monthData.total);
            updateDeleteButton();
            updateArrowButtons();
            enterNewModeIfEmpty();

            // 載入完成後關閉進度條
            hideSpinner();
          } catch (error) {
            alert(`載入月份 ${monthName} 失敗: ${error.message || error.toString()}`);
            // 恢復到原來的月份
            currentSheetIndex = oldSheetIndex;
            if (monthSelect) {
              const oldSelectIndex = oldSheetIndex - 2;
              if (oldSelectIndex >= 0 && oldSelectIndex < sheetNames.length) {
                monthSelect.value = String(oldSelectIndex);
              }
            }
            hideSpinner();
          } finally {
            isSwitchingMonth = false;
          }
        }
      } catch (e) {
        // 如果載入失敗，恢復原來的月份
        currentSheetIndex = oldSheetIndex;
        if (monthSelect) {
          const oldSelectIndex = oldSheetIndex - 2;
          if (oldSelectIndex >= 0 && oldSelectIndex < sheetNames.length) {
            monthSelect.value = String(oldSelectIndex);
          }
        }
        isSwitchingMonth = false;
          hideSpinner();
      }
    };

    monthSelect.addEventListener('change', monthSelectChangeHandler);

    // 初始載入目前選擇的月份資料（從記憶體讀取，不需要 spinner）
    // 如果記憶體中沒有資料，initMonthSelect 已經載入並顯示了
    if (loadContentFromMemory()) {
      // 從記憶體載入成功，只需要更新 UI
    updateDeleteButton();
    updateArrowButtons();
    }
  } catch (error) {
    // CORS / fetch 類錯誤在實際使用上不影響結果，這裡不再彈出提示視窗，避免干擾操作
  }
};


totalContainer.appendChild(columnsContainer);
  columnsContainer.appendChild(incomeColumn);
    incomeColumn.appendChild(incomeTitle);
    incomeColumn.appendChild(incomeAmount);
  columnsContainer.appendChild(expenseColumn);
    expenseColumn.appendChild(expenseTitle);
    expenseColumn.appendChild(expenseAmount);
  columnsContainer.appendChild(totalColumn);
    totalColumn.appendChild(totalTitle);
    totalColumn.appendChild(totalAmount);
budgetCardsContainer.appendChild(headerInfo);
budgetCardsContainer.appendChild(deleteButton);
budgetCardsContainer.appendChild(leftArrow);
budgetCardsContainer.appendChild(rightArrow);
budgetCardsContainer.appendChild(itemContainer);
budgetCardsContainer.appendChild(div1);
  div1.appendChild(categoryLabel);
  div1.appendChild(categorySelectContainer);
budgetCardsContainer.appendChild(div2);
budgetCardsContainer.appendChild(div3);
budgetCardsContainer.appendChild(div4);
budgetCardsContainer.appendChild(submitContainer);
  submitContainer.appendChild(saveButton);

categorySelect.addEventListener('change', () => {
  updateDivVisibility();
  if (allRecords.length > 0) {
    filterRecordsByType(categorySelect.value);
  }
});
updateDivVisibility();
saveButton.addEventListener('click', saveData);
saveButton.addEventListener('click', loadTotal);

// 為下拉選單容器添加防止回彈（主頁面由 CSS 處理）
// (function() {
//   // 檢查是否為拖拽元素
//   function isDragElement(target) {
//     return target.closest('.drag-handle') ||
//            target.closest('.option-item') ||
//            target.closest('[draggable="true"]') ||
//            target.classList.contains('drag-handle') ||
//            target.classList.contains('option-item') ||
//            target.hasAttribute('draggable');
//   }

//   // 硬鎖方案：在 dropdown 開啟時鎖定 body 滾動（防止整頁被拉開）
//   let bodyScrollLocked = false;
//   let scrollY = 0;

//   function lockBodyScroll() {
//     if (!bodyScrollLocked) {
//       // 記住當前滾動位置
//       scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;
//       console.log('[硬鎖] 鎖定 body 滾動，當前 scrollY:', scrollY);

//       // 同時鎖定 html 和 body（iOS 上真正的 scroll container 有時是 html）
//       document.documentElement.style.overflow = 'hidden';
//       document.body.style.overflow = 'hidden';

//       // 使用 fixed 定位保持視覺位置，避免跳動
//       document.body.style.position = 'fixed';
//       document.body.style.top = `-${scrollY}px`;
//       document.body.style.width = '100%';

//       bodyScrollLocked = true;
//       console.log('[硬鎖] 鎖定完成，bodyScrollLocked:', bodyScrollLocked);
//     } else {
//       console.log('[硬鎖] 已經鎖定，跳過');
//     }
//   }

//   function unlockBodyScroll() {
//     if (bodyScrollLocked) {
//       console.log('[硬鎖] 解鎖 body 滾動，恢復 scrollY:', scrollY);

//       // 還原 html 和 body 的 overflow
//       document.documentElement.style.overflow = '';
//       document.body.style.overflow = '';

//       // 還原 body 的定位樣式
//       document.body.style.position = '';
//       document.body.style.top = '';
//       document.body.style.width = '';

//       // 恢復到原本的滾動位置
//       window.scrollTo(0, scrollY);

//       bodyScrollLocked = false;
//       console.log('[硬鎖] 解鎖完成，bodyScrollLocked:', bodyScrollLocked);
//     } else {
//       console.log('[硬鎖] 未鎖定，跳過解鎖');
//     }
//   }

//   // 監聽所有下拉選單的顯示/隱藏
//   let dropdownObserver = null;
//   let styleObserver = null;
//   const observedDropdowns = new Set();

//   function checkDropdownsAndLock() {
//     // 重新查詢所有下拉選單（因為是動態創建的）
//     const dropdowns = document.querySelectorAll('.category-dropdown, .select-dropdown');
//     console.log('[硬鎖] 檢查下拉選單，找到', dropdowns.length, '個');

//     let anyOpen = false;
//     const openDropdowns = [];

//     dropdowns.forEach((dropdown, index) => {
//       const isOpen = dropdown.style.display === 'block' ||
//                     window.getComputedStyle(dropdown).display === 'block';
//       if (isOpen) {
//         anyOpen = true;
//         openDropdowns.push(index);
//       }

//       // 為新創建的下拉選單設置監聽
//       if (!observedDropdowns.has(dropdown)) {
//         observedDropdowns.add(dropdown);
//         if (styleObserver) {
//           styleObserver.observe(dropdown, {
//             attributes: true,
//             attributeFilter: ['style']
//           });
//           console.log('[硬鎖] 開始監聽新下拉選單', index);
//         }
//       }
//     });

//     if (openDropdowns.length > 0) {
//       console.log('[硬鎖] 下拉選單狀態變化，開啟的數量:', openDropdowns.length, '索引:', openDropdowns);
//     }

//     if (anyOpen) {
//       lockBodyScroll();
//     } else {
//       unlockBodyScroll();
//     }
//   }

//   function setupBodyScrollLock() {
//     console.log('[硬鎖] 開始初始化');

//     // 創建監聽下拉選單樣式變化的 observer
//     styleObserver = new MutationObserver(() => {
//       checkDropdownsAndLock();
//     });

//     // 創建監聽 DOM 變化的 observer（當有新的 dropdown 被創建時）
//     dropdownObserver = new MutationObserver((mutations) => {
//       let hasNewDropdown = false;
//       mutations.forEach(mutation => {
//         mutation.addedNodes.forEach(node => {
//           if (node.nodeType === 1) { // Element node
//             if (node.classList && (
//               node.classList.contains('category-dropdown') ||
//               node.classList.contains('select-dropdown')
//             )) {
//               hasNewDropdown = true;
//             }
//             // 檢查子節點
//             if (node.querySelectorAll) {
//               const childDropdowns = node.querySelectorAll('.category-dropdown, .select-dropdown');
//               if (childDropdowns.length > 0) {
//                 hasNewDropdown = true;
//               }
//             }
//           }
//         });
//       });

//       if (hasNewDropdown) {
//         console.log('[硬鎖] 檢測到新的下拉選單被創建');
//         checkDropdownsAndLock();
//       }
//     });

//     // 監聽整個 body 的變化
//     dropdownObserver.observe(document.body, {
//       childList: true,
//       subtree: true
//     });

//     // 初始檢查一次
//     checkDropdownsAndLock();

//     console.log('[硬鎖] 設置完成，開始監聽 DOM 變化');
//   }

//   // 為所有下拉選單容器添加防止回彈
//   function setupDropdownPrevention() {
//     const dropdowns = document.querySelectorAll('.category-dropdown, .select-dropdown, .options-list, .select-options');
//     dropdowns.forEach(dropdown => {
//       // 避免重複綁定
//       if (dropdown.dataset.bouncePrevented) return;
//       dropdown.dataset.bouncePrevented = 'true';

//       let dropdownTouchStartY = 0;

//       dropdown.addEventListener('touchstart', function(e) {
//         if (isDragElement(e.target) || window._isDragging) {
//           return;
//         }
//         dropdownTouchStartY = e.touches[0].clientY;
//       }, { passive: true });

//       dropdown.addEventListener('touchmove', function(e) {
//         if (window._isDragging || isDragElement(e.target)) {
//           return;
//         }

//         const currentY = e.touches[0].clientY;
//         const deltaY = currentY - dropdownTouchStartY;
//         const currentScrollTop = dropdown.scrollTop;
//         const scrollHeight = dropdown.scrollHeight;
//         const clientHeight = dropdown.clientHeight;

//         // 精準判斷：只在邊界且繼續向邊界方向滑動時阻止
//         // 使用 <= 1 而不是 === 0 以處理負值和次像素捨入（與設定頁保持一致）
//         const isAtTop = currentScrollTop <= 1;
//         const isAtBottom = currentScrollTop + clientHeight >= scrollHeight - 1;

//         // 在頂部且向下拉（deltaY > 0）時阻止
//         if (isAtTop && deltaY > 0) {
//           if (e.cancelable) {
//             e.preventDefault();
//           }
//           dropdown.scrollTop = 0;
//         }
//         // 在底部且向上拉（deltaY < 0）時阻止
//         else if (isAtBottom && deltaY < 0) {
//           if (e.cancelable) {
//             e.preventDefault();
//           }
//           dropdown.scrollTop = Math.max(0, scrollHeight - clientHeight);
//         }
//       }, { passive: false });
//     });
//   }

//   // 頁面載入後設置下拉選單
//   if (document.readyState === 'loading') {
//     document.addEventListener('DOMContentLoaded', () => {
//       setupDropdownPrevention();
//       // 啟用硬鎖方案（防止整頁被拉開）
//       setupBodyScrollLock();
//     });
//   } else {
//     setupDropdownPrevention();
//     // 啟用硬鎖方案（防止整頁被拉開）
//     setupBodyScrollLock();
//   }

//   // 監聽動態添加的下拉選單
//   const observer = new MutationObserver(setupDropdownPrevention);
//   observer.observe(document.body, { childList: true, subtree: true });
// })();

document.addEventListener('DOMContentLoaded', async function() {
  // 清除舊的快取資料，強制從 API 重新載入
  try {
    Object.keys(sessionStorage).forEach(key => {
      if (key.startsWith('budget_monthData_')) {
        sessionStorage.removeItem(key);
      }
    });
    // 清除記憶體中的資料
    Object.keys(allMonthsData).forEach(key => delete allMonthsData[key]);
  } catch (e) {
    // 忽略錯誤
  }

  // 立即顯示載入動畫，讓用戶知道頁面正在載入
  showSpinner();

  document.getElementsByClassName('post-content')[0].appendChild(totalContainer);
  document.getElementsByClassName('post-content')[0].appendChild(budgetCardsContainer);

  try {
    // 非阻塞載入「下拉選單」sheet 的最新選項
    const refreshDropdowns = () => {
      loadDropdownOptions().then(() => {
        // 如果當前顯示的是支出類別，重新渲染
        const categorySelect = document.getElementById('category-select');
        if (categorySelect && categorySelect.value === '支出') {
          updateDivVisibility('支出');
        }
      }).catch(err => {
      });
    };

    refreshDropdowns();

    // 監聽設定頁的更新通知（當設定頁更新下拉選單後，自動重新載入）
    window.addEventListener('storage', (e) => {
      if (e.key === 'dropdownUpdated') {
        refreshDropdowns();
      }
    });

    // 也監聽同頁面的 storage 事件（因為 storage 事件只在其他標籤頁觸發）
    let lastUpdateTime = localStorage.getItem('dropdownUpdated');
    setInterval(() => {
      const current = localStorage.getItem('dropdownUpdated');
      if (current && current !== lastUpdateTime) {
        lastUpdateTime = current;
        refreshDropdowns();
      }
    }, 1000); // 每秒檢查一次

    // initMonthSelect 內部會處理載入並在完成時隱藏 spinner
    await initMonthSelect(); // 先載入月份清單並載入對應月份資料
    updateDeleteButton(); // 初始化刪除按鈕顯示狀態
  } catch (error) {
    hideSpinner(); // 確保錯誤時也隱藏 spinner
    const errorContainer = document.createElement('div');
    errorContainer.innerHTML = '載入失敗: ' + error.message;
    errorContainer.style.color = 'red';
    errorContainer.style.marginTop = '20px';
    document.getElementsByClassName('post-content')[0].appendChild(errorContainer);
  }
});

</script>
