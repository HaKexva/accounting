---
layout: page
title: 預算表
permalink: /budget_table/
---

<link rel="stylesheet" href="{{ '/assets/budget-table.css' | relative_url }}">

<div id="user-info"></div>

<script>

// 新版預算／支出 API（與支出頁一致）
const base = "https://script.google.com/macros/s/AKfycbyrRS1rmb2S_M3BNjn_Z-ZR5uZWmpG1j1MDPTF8YqMFzFQxSKFtTjK_tGXuEfa6sP3p/exec";

// ===== 全域狀態變數 =====
let currentSheetIndex = 2; // 目前選擇的試算表分頁索引（2 代表第三個分頁）
let sheetNames = []; // 所有月份分頁名稱（不含前兩個「空白表」、「下拉選單」）
let allMonthsData = {}; // 預先載入的所有月份資料（key: sheetIndex, value: { data, total }）
let allRecords = []; // 目前選擇月份的記錄（收入 + 支出）
let filteredRecords = []; // 目前類型過濾後的記錄
let currentRecordIndex = 0;
let isNewMode = false; // 是否在新增模式
let currentRecordNumber = null; // 目前顯示的記錄編號
let isSwitchingMonth = false; // 防止快速連續切換月份
let monthSelectChangeHandler = null; // 儲存月份選擇事件處理器，用於移除
let currentAbortController = null; // 用於取消正在進行的請求

// ===== 下拉選單選項（從「下拉選單」sheet=1 載入）=====
let EXPENSE_CATEGORY_OPTIONS = [
  { value: '生活花費：食', text: '生活花費：食' },
  { value: '生活花費：衣與外貌', text: '生活花費：衣與外貌' },
  { value: '生活花費：住、居家裝修、衛生用品、次月繳納帳單', text: '生活花費：住、居家裝修、衛生用品、次月繳納帳單' },
  { value: '生活花費：行', text: '生活花費：行' },
  { value: '生活花費：育', text: '生活花費：育' },
  { value: '生活花費：樂', text: '生活花費：樂' },
  { value: '生活花費：健（醫療）', text: '生活花費：健（醫療）' },
  { value: '生活花費：帳單', text: '生活花費：帳單' },
  { value: '儲蓄：退休金、醫療預備金、過年紅包支出', text: '儲蓄：退休金、醫療預備金、過年紅包支出' },
  { value: '家人：過年紅包、紀念日', text: '家人：過年紅包、紀念日' }
];

// 從「下拉選單」sheet=1 載入最新選項
// 注意：下拉選單資料在支出表的 Google Sheet 中，所以使用同一個新版 URL
const baseExpenseForDropdown = "https://script.google.com/macros/s/AKfycby8s1gyATpTHzd3ZQl0QgQjaPYaHmuxWg-IQbD7-EFamqObcGcCdzucgnQmnB_1T7Rx/exec";

async function loadDropdownOptions() {
  try {
    const params = { name: "Show Tab Data", sheet: 1, _t: Date.now() };
    const url = `${baseExpenseForDropdown}?${new URLSearchParams(params)}`;
    const res = await fetch(url, {
      method: "GET",
      redirect: "follow",
      mode: "cors",
      cache: "no-store"
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const responseData = await res.json();
    // 處理不同的資料格式
    let data = null;
    
    // 如果是陣列，直接使用
    if (Array.isArray(responseData)) {
      data = responseData;
    } 
    // 如果是物件，可能是命名範圍的格式，嘗試找到第一個陣列值
    else if (typeof responseData === 'object' && responseData !== null) {
      // 尋找第一個值是陣列的鍵
      for (const key in responseData) {
        if (Array.isArray(responseData[key]) && responseData[key].length > 0) {
          data = responseData[key];
          break;
        }
      }
    }
    
    if (!data || !Array.isArray(data) || data.length === 0) {
      return;
    }

    const headerRow = data[0];
    // 找對應欄位（預算表使用「支出－項目」）
    const colCategory = findHeaderColumn(headerRow, ['支出－項目', '支出-項目', '消費類別', '類別']);
    const readColumn = (col) => {
      const arr = [];
      if (col < 0) return arr;
      const seen = new Set();
      for (let i = 1; i < data.length; i++) {
        const row = data[i];
        if (!row) continue;
        const raw = row[col];
        if (raw === undefined || raw === null) continue;
        const val = raw.toString().trim();
        if (!val || seen.has(val)) continue;
        seen.add(val);
        arr.push({ value: val, text: val });
      }
      return arr;
    };

    if (colCategory >= 0) {
      EXPENSE_CATEGORY_OPTIONS = readColumn(colCategory);
      // 如果當前顯示的是支出類別，重新渲染
      const categorySelect = document.getElementById('category-select');
      if (categorySelect && categorySelect.value === '支出') {
        // 保存當前選擇的值（如果有）
        const currentCategorySelect = document.getElementById('expense-category-select');
        const currentValue = currentCategorySelect ? currentCategorySelect.value : '';
        updateDivVisibility('支出');
        // 如果之前有選擇值，嘗試恢復
        if (currentValue) {
          setTimeout(() => {
            const newCategorySelect = document.getElementById('expense-category-select');
            if (newCategorySelect && newCategorySelect.querySelector(`option[value="${currentValue}"]`)) {
              newCategorySelect.value = currentValue;
              // 同步更新自訂下拉顯示文字
              const selectContainer = newCategorySelect.parentElement;
              if (selectContainer) {
                const selectDisplay = selectContainer.querySelector('.select-display');
                if (selectDisplay) {
                  const selectText = selectDisplay.querySelector('.select-text');
                  if (selectText) {
                    const selectedOpt = newCategorySelect.options[newCategorySelect.selectedIndex];
                    selectText.textContent = selectedOpt ? selectedOpt.textContent : '';
                  }
                }
              }
            }
          }, 100);
        }
      }
    } else {
    }

  } catch (err) {
  }
}

function findHeaderColumn(headerRow, keywords) {
  for (let c = 0; c < headerRow.length; c++) {
    const headerText = (headerRow[c] || '').toString().trim();
    if (!headerText) continue;
    if (keywords.some(k => headerText.includes(k))) return c;
  }
  return -1;
}

// ===== 統一的 API 調用函數 =====
async function callAPI(postData) {
  // 取消之前的請求（如果存在）
  if (currentAbortController) {
    currentAbortController.abort();
  }
  
  // 創建新的 AbortController
  currentAbortController = new AbortController();
  const signal = currentAbortController.signal;
  
  try {
    const response = await fetch(base, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      signal: signal, // 添加 abort signal
      body: JSON.stringify(postData)
    });
    
    const responseText = await response.text();
    if (!responseText || responseText.trim() === '') {
      currentAbortController = null;
      return { success: true, data: null, total: null };
    }
    
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      currentAbortController = null;
      throw new Error('後端響應格式錯誤: ' + responseText.substring(0, 100));
    }
    
    if (!response.ok || !result.success) {
      currentAbortController = null;
      throw new Error(result.message || result.error || '操作失敗');
    }
    
    // 請求成功後，清除 AbortController
    currentAbortController = null;
    return result;
  } catch (error) {
    // 如果是取消請求，不拋出錯誤
    if (error.name === 'AbortError') {
      currentAbortController = null;
      throw new Error('請求已取消');
    }
    currentAbortController = null;
    throw error;
  }
}

// ===== 找到最接近的月份（當前月份或最新月份）=====
function findClosestMonth() {
  if (sheetNames.length === 0) return 2;
  
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth() + 1;
  const currentMonthStr = `${currentYear}${String(currentMonth).padStart(2, '0')}`;
  
  const currentIndex = sheetNames.findIndex(name => name === currentMonthStr);
  if (currentIndex !== -1) {
    return currentIndex + 2;
  }
  
  return sheetNames.length + 1; // 最後一個月份的 sheetIndex
}

// ===== 如果沒有記錄，進入新增模式 =====
function enterNewModeIfEmpty() {
  if (filteredRecords.length > 0) return;
  
  const currentType = categorySelect ? categorySelect.value : '支出';
  let nextNumber = 1;
  const allRecordsOfType = allRecords.filter(r => r.type === currentType);
  if (allRecordsOfType.length > 0) {
    const maxNum = Math.max(
      ...allRecordsOfType
        .map(r => parseInt(r.row[0], 10))
        .filter(n => Number.isFinite(n) && n > 0)
    );
    if (Number.isFinite(maxNum) && maxNum > 0) {
      nextNumber = maxNum + 1;
    }
  }
  isNewMode = true;
  if (typeof recordNumber !== 'undefined') {
    recordNumber.textContent = ''; // 新增模式不顯示編號
    recordNumber.style.display = 'none'; // 隱藏編號
  }
  if (typeof recordDate !== 'undefined') {
    recordDate.textContent = getNowFormattedDateTime();
  }
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  if (itemInput) itemInput.value = '';
  if (costInput) costInput.value = '';
  if (noteInput) noteInput.value = '';
  updateDeleteButton();
  updateArrowButtons();
}

// 根據目前選擇的類型過濾記錄
function filterRecordsByType(type) {
  filteredRecords = allRecords.filter(r => r.type === type);
  
  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length && filteredRecords.length > 0) {
    currentRecordIndex = filteredRecords.length - 1;
  } else if (filteredRecords.length === 0) {
    currentRecordIndex = 0;
  }

  //  新增模式：切換收入 / 支出模式：重新計算該類型的下一個編號
  if (isNewMode) {
    // 計算新類型中最大的編號 + 1
    let nextNumber = 1;
    if (filteredRecords.length > 0) {
      const maxNum = Math.max(
        ...filteredRecords
          .map(r => parseInt(r.row[0], 10))
          .filter(n => Number.isFinite(n) && n > 0)
      );
      if (Number.isFinite(maxNum) && maxNum > 0) {
        nextNumber = maxNum + 1;
      }
    }
    
    // 新增模式不顯示編號
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = ''; // 新增模式不顯示編號
      recordNumber.style.display = 'none'; // 隱藏編號
    }
    
    // 清空表單，準備新增
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    
    // 如果是支出，重置類別選擇
    if (type === '支出') {
      const categorySelectElement = document.getElementById('expense-category-select');
      if (categorySelectElement && categorySelectElement.options.length > 0) {
        categorySelectElement.value = categorySelectElement.options[0].value;
        const selectContainer = categorySelectElement.parentElement;
        if (selectContainer) {
          const selectDisplay = selectContainer.querySelector('div');
          if (selectDisplay) {
            const selectText = selectDisplay.querySelector('div');
            if (selectText) {
              selectText.textContent = categorySelectElement.options[0].textContent;
            }
          }
        }
      }
    }
    
    updateArrowButtons();
    updateDeleteButton(); // 更新刪除按鈕顯示
    return;
  }

  // 嘗試找到相同編號的記錄
  if (currentRecordNumber !== null && filteredRecords.length > 0) {
    const sameNumberIndex = filteredRecords.findIndex(r => {
      const num = parseInt(r.row[0], 10);
      return Number.isFinite(num) && num > 0 && num === currentRecordNumber;
    });
    
    if (sameNumberIndex >= 0) {
      currentRecordIndex = sameNumberIndex;
      showRecord(sameNumberIndex);
      updateArrowButtons();
      return;
    }
  }
  
  // 如果找不到相同編號，顯示第一筆
  currentRecordIndex = 0;
  if (filteredRecords.length > 0) {
    showRecord(0);
  } else {
    // 沒有記錄時，清空表單並更新按鈕
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = ''; // 新增模式不顯示編號
      recordNumber.style.display = 'none'; // 隱藏編號
    }
    updateArrowButtons();
    updateDeleteButton(); // 更新刪除按鈕顯示
  }
}

// 取得現在時間並格式化為 YYYY/MM/DD HH:MM
function getNowFormattedDateTime() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  return `${year}/${month}/${day} ${hours}:${minutes}`;
}

// 將各種時間字串格式統一轉為 YYYY/MM/DD HH:MM
function formatRecordDateTime(raw) {
  if (!raw) return '';
  
  // 嘗試以 Date 解析（支援 ISO 例如 2025-11-30T12:34:56Z）
  const dt = new Date(raw);
  if (Number.isNaN(dt.getTime())) {
    // 解析失敗時，保留原字串（例如已經是 2025/11/30 12:34）
    return raw;
  }
  
  const year = dt.getFullYear();
  const month = String(dt.getMonth() + 1).padStart(2, '0');
  const day = String(dt.getDate()).padStart(2, '0');
  const hours = String(dt.getHours()).padStart(2, '0');
  const minutes = String(dt.getMinutes()).padStart(2, '0');
  return `${year}/${month}/${day} ${hours}:${minutes}`;
}

// 顯示第 index 筆記錄到卡片上的輸入欄位
function showRecord(index) {
  if (!filteredRecords.length) return;
  
  // 確保 index 在有效範圍內
  if (index < 0 || index >= filteredRecords.length) {
    index = Math.max(0, Math.min(index, filteredRecords.length - 1));
  }
  
  currentRecordIndex = index; // 更新當前索引
  const { type, row } = filteredRecords[index];
  isNewMode = false; // 顯示記錄時退出新增模式
  updateDeleteButton(); // 更新刪除按鈕顯示

  // 更新左上角編號：只顯示該記錄自己的編號（row[0]），不顯示收入/支出
  if (typeof recordNumber !== 'undefined') {
    const num = parseInt(row[0], 10);
    const recordNum = Number.isFinite(num) && num > 0 ? num : (index + 1);
    recordNumber.textContent = `#${String(recordNum).padStart(3, '0')}`;
    currentRecordNumber = recordNum; // 記錄目前編號
  }

  // 更新右上角「資料時間」：使用每筆記錄的時間欄位（row[1]，通常為試算表中的時間 / 最後修正時間）
  if (typeof recordDate !== 'undefined') {
    recordDate.textContent = formatRecordDateTime(row[1] || '');
  }

  // 設定「支出 / 收入」大類（只改畫面，不觸發 change 事件，避免遞迴）
  if (typeof categorySelect !== 'undefined' && typeof categorySelectText !== 'undefined') {
    const value = type === '收入' || type === '支出' ? type : '支出';
    categorySelect.value = value;
    categorySelectText.textContent = value;
    // 直接更新欄位顯示
    if (typeof updateDivVisibility === 'function') {
      updateDivVisibility();
    }
  }

  // 等 div2 / div3 / div4 依據類別建立好之後再填資料
  // 使用較長的延遲，確保 updateDivVisibility 完成
  setTimeout(() => {
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');

    if (type === '支出') {
      // 支出：[編號, 時間, category, item, cost, note]
      const categorySelectElement = document.getElementById('expense-category-select');
      if (categorySelectElement) {
        categorySelectElement.value = row[2] || '';
        // 同步更新自訂下拉顯示文字（若存在）
        const selectContainer = categorySelectElement.parentElement;
        if (selectContainer) {
          const selectDisplay = selectContainer.querySelector('div');
          if (selectDisplay) {
            const selectText = selectDisplay.querySelector('div');
            if (selectText) {
              selectText.textContent = row[2] || '';
            }
          }
        }
      }
      if (itemInput) {
        itemInput.value = row[3] || '';
        // 確保值已設定（避免 placeholder 顯示）
        if (itemInput.value === '' && row[3]) {
          itemInput.value = row[3];
        }
      }
      if (costInput) costInput.value = row[4] || '';
      if (noteInput) noteInput.value = row[5] || '';
    } else {
      // 收入：[編號, 時間, item, cost, note]
      if (itemInput) {
        itemInput.value = row[2] || '';
        // 確保值已設定（避免 placeholder 顯示）
        if (itemInput.value === '' && row[2]) {
          itemInput.value = row[2];
        }
      }
      if (costInput) costInput.value = row[3] || '';
      if (noteInput) noteInput.value = row[4] || '';
    }
    
    // 更新箭頭按鈕狀態
    updateArrowButtons();
  }, 150);
}

// 處理從 Apps Script 回傳的資料（用於更新 allRecords）
const processDataFromResponse = (data, shouldFilter = true) => {
  // 先清空目前的記錄
  allRecords = [];

  if (!data) return;

  // 獲取當前月份名稱
  const monthIndex = currentSheetIndex - 2;
  const currentMonthName = (monthIndex >= 0 && monthIndex < sheetNames.length) ? sheetNames[monthIndex] : '';
  
  console.log(`[processDataFromResponse] 當前月份名稱: ${currentMonthName}, sheetIndex: ${currentSheetIndex}`);
  console.log(`[processDataFromResponse] 資料類型:`, Array.isArray(data) ? 'Array' : typeof data);
  console.log(`[processDataFromResponse] 資料 keys:`, Array.isArray(data) ? `Array(${data.length})` : Object.keys(data));
  
  // 使用 Set 追蹤已處理的記錄，避免重複
  const processedRecords = new Set();
  let processedCount = 0;
  
  // 預算表只處理物件格式的資料（命名範圍格式）
  // 命名範圍：當月收入202506、當月支出預算202506
  // 預算格式：收入 [編號, 時間, item, cost, note] (5欄)，支出 [編號, 時間, category, item, cost, note] (6欄)
  if (data && typeof data === 'object' && !Array.isArray(data)) {
    console.log(`[processDataFromResponse] 處理物件格式資料，keys:`, Object.keys(data));
    
    // 處理物件格式的資料（命名範圍格式）
    Object.keys(data).forEach(key => {
      const rows = data[key] || [];
      
      console.log(`[processDataFromResponse] 處理命名範圍: ${key}, rows.length: ${rows.length}`);
      
      const isIncome = key.includes('收入');
      const isExpense = key.includes('支出');
      const type = isIncome ? '收入' : (isExpense ? '支出' : '');
      
      if (!type) {
        console.log(`[processDataFromResponse] 跳過非收入/支出命名範圍: ${key}`);
        return;
      }
      
      // 只處理當前月份的資料（命名範圍名稱應該包含當前月份）
      const isCurrentMonth = currentMonthName && key.includes(currentMonthName);
      if (!isCurrentMonth) {
        console.warn(`[processDataFromResponse] 跳過非當前月份的資料: ${key} (期望包含: ${currentMonthName})`);
        return;
      }
      
      console.log(`[processDataFromResponse] 處理 ${key}, 類型: ${type}, 月份匹配: ${isCurrentMonth}`);

      rows.forEach((row, rowIndex) => {
        if (!row || !Array.isArray(row) || row.length === 0) {
          console.log(`[processDataFromResponse] 跳過空行: key=${key}, rowIndex=${rowIndex}`);
          return;
        }
        
        // 預算格式檢查：收入應該是5欄，支出應該是6欄
        if (type === '收入' && row.length !== 5) {
          console.warn(`[processDataFromResponse] 收入資料格式錯誤: key=${key}, rowIndex=${rowIndex}, length=${row.length}, 期望5欄`);
          return;
        }
        if (type === '支出' && row.length !== 6) {
          console.warn(`[processDataFromResponse] 支出資料格式錯誤: key=${key}, rowIndex=${rowIndex}, length=${row.length}, 期望6欄`);
          return;
        }
        
        // 跳過標題行和總計行
        const firstCell = String(row[0] || '').trim();
        if (firstCell === '交易日期' || firstCell === '編號' || firstCell === '日期' || firstCell === '時間' || firstCell === '總計' || firstCell === '') {
          console.log(`[processDataFromResponse] 跳過標題行或總計行: key=${key}, rowIndex=${rowIndex}, firstCell="${firstCell}"`);
          return;
        }
        
        // 檢查是否為有效記錄（第一欄應該是數字編號）
        const num = parseInt(row[0], 10);
        if (!Number.isFinite(num) || num <= 0) {
          console.log(`[processDataFromResponse] 跳過無效編號: key=${key}, rowIndex=${rowIndex}, firstCell="${firstCell}", num=${num}`);
          return;
        }
        
        // 使用編號+時間作為唯一標識，避免重複
        const recordKey = `${type}_${num}_${row[1] || ''}`;
        if (processedRecords.has(recordKey)) {
          console.warn(`[processDataFromResponse] 跳過重複記錄: ${type} #${num}`);
          return;
        }
        processedRecords.add(recordKey);
        
        console.log(`[processDataFromResponse] ✓ 添加預算記錄: ${type} #${num}, row=`, JSON.stringify(row));
        allRecords.push({ type, row });
        processedCount++;
      });
    });
  } else if (Array.isArray(data)) {
    console.error(`[processDataFromResponse] 錯誤：收到陣列格式資料，這應該是命名範圍格式！`);
    console.error(`[processDataFromResponse] 資料長度: ${data.length}`);
    console.error(`[processDataFromResponse] 資料前3行:`, data.slice(0, 3));
  } else {
    console.error(`[processDataFromResponse] 不支援的資料格式:`, typeof data, Array.isArray(data));
  }
  
  console.log(`[processDataFromResponse] 處理完成: 總共處理 ${processedCount} 筆記錄`);
  
  // 根據目前選擇的類型過濾記錄（預設顯示支出）
  if (shouldFilter) {
    const currentType = categorySelect ? categorySelect.value : '支出';
    filterRecordsByType(currentType);
  }
};

// 圓餅圖已取消，不再繪製（保留函式介面以避免其他程式碼出錯）
const renderPieChart = (_totalData) => {
  return;
};

// 更新總計顯示 + 圓餅圖
const updateTotalDisplay = (totalData) => {
  if (Array.isArray(totalData) && totalData.length >= 3) {
    incomeAmount.textContent = totalData[0];
    expenseAmount.textContent = totalData[1];
    totalAmount.textContent = totalData[2];
    updateTotalColor(totalData[2]);
    renderPieChart(totalData);
  }
};

// 載入單個月份的資料和總計
const loadMonthData = async (sheetIndex, useGlobalAbortController = true) => {
  // 驗證 sheetIndex 是否有效
  if (!Number.isFinite(sheetIndex) || sheetIndex < 2) {
    throw new Error(`無效的 sheet 索引: ${sheetIndex}`);
  }

  let signal;
  let abortController;
  
  if (useGlobalAbortController) {
    // 取消之前的請求（如果存在）
    if (currentAbortController) {
      currentAbortController.abort();
    }
    
    // 創建新的 AbortController
    currentAbortController = new AbortController();
    signal = currentAbortController.signal;
  } else {
    // 為預載入任務創建獨立的 AbortController
    abortController = new AbortController();
    signal = abortController.signal;
  }

  // 從試算表抓出「當月收入 / 支出」等資料 - 添加時間戳避免快取
  const monthIndex = sheetIndex - 2;
  const currentMonthName = (monthIndex >= 0 && monthIndex < sheetNames.length) ? sheetNames[monthIndex] : '';
  
  const dataParams = { name: "Show Tab Data", sheet: sheetIndex, _t: Date.now() };
  const dataUrl = `${base}?${new URLSearchParams(dataParams)}`;
  
  let data;
  try {
    const res = await fetch(dataUrl, {
      method: "GET",
      redirect: "follow",
      mode: "cors",
      cache: "no-store", // 強制不使用快取
      signal: signal // 添加 abort signal
    });
    
    if (!res.ok) {
      throw new Error(`載入資料失敗: HTTP ${res.status} ${res.statusText}`);
    }
    
    data = await res.json();
    
    console.log(`[loadMonthData] 原始資料類型:`, Array.isArray(data) ? 'Array' : typeof data);
    console.log(`[loadMonthData] 原始資料 keys:`, Array.isArray(data) ? `Array(${data.length})` : Object.keys(data));
    
    // 如果資料是陣列格式，需要轉換成命名範圍格式
    if (Array.isArray(data)) {
      console.log(`[loadMonthData] 收到陣列格式資料，轉換為命名範圍格式`);
      console.log(`[loadMonthData] 陣列長度: ${data.length}`);
      
      // 將陣列轉換為命名範圍格式
      // 預算格式：收入 [編號, 時間, item, cost, note] (5欄)
      //          支出 [編號, 時間, category, item, cost, note] (6欄)
      const convertedData = {};
      let incomeRows = [];
      let expenseRows = [];
      
      data.forEach((row, rowIndex) => {
        if (!row || !Array.isArray(row) || row.length === 0) return;
        
        // 跳過標題行和總計行
        const firstCell = String(row[0] || '').trim();
        if (firstCell === '交易日期' || firstCell === '編號' || firstCell === '總計' || firstCell === '') {
          return;
        }
        
        // 根據欄位數量判斷類型
        if (row.length === 5) {
          // 收入格式：[編號, 時間, item, cost, note]
          incomeRows.push(row);
        } else if (row.length === 6) {
          // 支出格式：[編號, 時間, category, item, cost, note]
          expenseRows.push(row);
        } else {
          // 其他格式（如10欄的支出記錄）跳過，因為預算表只需要預算資料
          console.log(`[loadMonthData] 跳過非預算格式行: rowIndex=${rowIndex}, length=${row.length}`);
        }
      });
      
      // 轉換為命名範圍格式
      if (incomeRows.length > 0) {
        convertedData[`當月收入${currentMonthName}`] = incomeRows;
      }
      if (expenseRows.length > 0) {
        convertedData[`當月支出預算${currentMonthName}`] = expenseRows;
      }
      
      console.log(`[loadMonthData] 轉換後資料 keys:`, Object.keys(convertedData));
      console.log(`[loadMonthData] 收入筆數: ${incomeRows.length}, 支出筆數: ${expenseRows.length}`);
      
      data = convertedData;
    } else {
      // 物件格式（命名範圍格式），檢查命名範圍是否存在
      const expectedIncomeKey = `當月收入${currentMonthName}`;
      const expectedExpenseKey = `當月支出預算${currentMonthName}`;
      const hasIncome = data.hasOwnProperty(expectedIncomeKey);
      const hasExpense = data.hasOwnProperty(expectedExpenseKey);
      
      console.log(`[loadMonthData] 檢查命名範圍: ${expectedIncomeKey}=${hasIncome}, ${expectedExpenseKey}=${hasExpense}`);
      console.log(`[loadMonthData] 實際資料 keys:`, Object.keys(data));
    }
    
    // 調試：檢查 202506 月份的資料
    if (currentMonthName === '202506') {
      console.log(`[202506 調試] 載入的資料 keys:`, Object.keys(data));
      Object.keys(data).forEach(key => {
        const rows = data[key] || [];
        console.log(`[202506 調試] ${key}: ${rows.length} 筆資料`);
        if (rows.length > 0) {
          console.log(`[202506 調試] ${key} 第一筆資料:`, rows[0]);
          console.log(`[202506 調試] ${key} 第一筆資料類型:`, typeof rows[0], Array.isArray(rows[0]));
          if (Array.isArray(rows[0])) {
            console.log(`[202506 調試] ${key} 第一筆資料長度:`, rows[0].length);
            console.log(`[202506 調試] ${key} 第一筆資料內容:`, rows[0]);
          }
        }
      });
    }
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error(`載入月份 ${currentMonthName} (sheetIndex: ${sheetIndex}) 被取消`);
    }
    console.error(`載入月份 ${currentMonthName} (sheetIndex: ${sheetIndex}) 資料失敗:`, error);
    throw error;
  }

  // 載入總計 - 添加時間戳避免快取
  const TotalParams = { name: "Show Total", sheet: sheetIndex, _t: Date.now() };
  const Totalurl = `${base}?${new URLSearchParams(TotalParams)}`;
  const Totalres = await fetch(Totalurl, {
    method: "GET",
    redirect: "follow",
    mode: "cors",
    cache: "no-store", // 強制不使用快取
    signal: signal // 添加 abort signal
  });
  
  if (!Totalres.ok) {
    throw new Error(`載入總計失敗: HTTP ${Totalres.status} ${Totalres.statusText}`);
  }
  
  const totalData = await Totalres.json();
  
  // 請求成功後，清除 AbortController（僅當使用全局 AbortController 時）
  if (useGlobalAbortController) {
    currentAbortController = null;
  }
  
  // 根據資料計算總計（因為 Google Apps Script 的總計可能有問題）
  let calculatedIncome = 0;
  let calculatedExpense = 0;
  let incomeCount = 0;
  let expenseCount = 0;
  
  // 使用 Set 來追蹤已處理的記錄，避免重複計算
  const processedIncomeRecords = new Set();
  const processedExpenseRecords = new Set();
  
  if (data && typeof data === 'object') {
    // 調試：檢查 202506 月份的資料過濾
    // 根據新的 Apps Script，數據格式是：
    // key 是命名範圍名稱（如 "當月收入202506"、"當月支出預算202506"）
    // value 是 2D 數組（已過濾空行）
    Object.keys(data).forEach(key => {
      const rows = data[key] || [];
      
      // 根據命名範圍名稱判斷類型
      // 命名範圍格式：當月收入202506 或 當月支出預算202506
      const isIncome = key.includes('收入');
      const isExpense = key.includes('支出');
      
      if (!isIncome && !isExpense) {
        return; // 跳過不是收入或支出的資料
      }
      
      // 只處理當前月份的資料（命名範圍名稱應該包含當前月份）
      const isCurrentMonth = currentMonthName && key.includes(currentMonthName);
      if (!isCurrentMonth) {
        return; // 跳過不是當前月份的資料
      }
      
      rows.forEach((row, rowIndex) => {
        // 確保 row 是陣列
        if (!row || !Array.isArray(row) || row.length === 0) return;
        
        // 檢查是否為空行（所有欄位都是空）
        const isEmptyRow = row.every(cell => cell === '' || cell === null || cell === undefined);
        if (isEmptyRow) {
          return;
        }
        
        // 跳過總計行（第一欄是 "總計" 或空字串）
        const firstCell = row[0];
        if (firstCell === '交易日期' || firstCell === '總計' || firstCell === '' || firstCell === null || firstCell === undefined) {
          return;
        }
        
        // 檢查是否為有效記錄（第一欄應該是數字編號）
        const num = parseInt(firstCell, 10);
        if (!Number.isFinite(num) || num <= 0) {
          return;
        }
        
        // 檢查是否已經處理過這筆記錄（使用編號+時間作為唯一標識）
        const recordKey = `${num}_${row[1] || ''}`;
        if (isIncome) {
          if (processedIncomeRecords.has(recordKey)) {
            return;
          }
          processedIncomeRecords.add(recordKey);
        } else if (isExpense) {
          if (processedExpenseRecords.has(recordKey)) {
            return;
          }
          processedExpenseRecords.add(recordKey);
        }
        
        // 收入：[編號, 時間, item, cost, note] - cost 在索引 3 (D欄)
        // 支出：[編號, 時間, category, item, cost, note] - cost 在索引 4 (K欄)
        const costIndex = isIncome ? 3 : (isExpense ? 4 : -1);
        if (costIndex >= 0 && row[costIndex] !== undefined && row[costIndex] !== null && row[costIndex] !== '') {
          const cost = parseFloat(row[costIndex]);
          if (Number.isFinite(cost) && cost !== 0) { // 允許負數，但不累加0
            if (isIncome) {
              calculatedIncome += cost;
              incomeCount++;
            } else if (isExpense) {
              calculatedExpense += cost;
              expenseCount++;
            }
          }
        }
      });
    });
  }
  
  const calculatedTotal = calculatedIncome - calculatedExpense;
  const calculatedTotalData = [calculatedIncome, calculatedExpense, calculatedTotal];
  
  // 直接保存原始資料，不需要轉換格式
  // Apps Script 返回的格式已經是標準格式（如 "當月收入202506"、"當月支出預算202506"）
  // 保存時保持原樣，讀取時根據月份名稱匹配即可
  
  console.log(`[loadMonthData] 保存資料 keys:`, Object.keys(data));
  console.log(`[loadMonthData] 月份: ${currentMonthName}, 總計:`, calculatedTotalData);
  
  // 使用計算的總計，而不是 API 返回的總計
  return { data, total: calculatedTotalData };
};

// 預先載入其他月份的資料（按順序：先下一個月，然後倒推往前）
const preloadAllMonthsData = async (baseProgress = 2, totalProgress = 0) => {
  console.log('[預載] 開始預載所有月份資料');
  console.log('[預載] sheetNames:', sheetNames);
  console.log('[預載] currentSheetIndex:', currentSheetIndex);
  console.log('[預載] 目前 allMonthsData keys:', Object.keys(allMonthsData));
  
  if (sheetNames.length === 0) {
    console.log('[預載] sheetNames 為空，跳過預載');
    return;
  }
  
  // 找出當前月份在 sheetNames 中的索引
  const currentMonthIdx = sheetNames.findIndex((name, idx) => {
    const sheetIndex = idx + 2;
    return sheetIndex === currentSheetIndex;
  });
  
  if (currentMonthIdx === -1) {
    console.log('[預載] 找不到當前月份，跳過預載');
    return;
  }
  
  // 構建載入順序：先下一個月（currentMonthIdx + 1），然後倒推往前（currentMonthIdx - 1, currentMonthIdx - 2, ...）
  const loadOrder = [];
  
  // 先加入下一個月及之後的月份（從 currentMonthIdx + 1 開始）
  for (let i = currentMonthIdx + 1; i < sheetNames.length; i++) {
    const sheetIndex = i + 2;
    if (!allMonthsData[sheetIndex]) {
      loadOrder.push({ idx: i, sheetIndex, name: sheetNames[i] });
    }
  }
  
  // 然後倒推往前加入之前的月份（從 currentMonthIdx - 1 開始）
  for (let i = currentMonthIdx - 1; i >= 0; i--) {
    const sheetIndex = i + 2;
    if (!allMonthsData[sheetIndex]) {
      loadOrder.push({ idx: i, sheetIndex, name: sheetNames[i] });
    }
  }
  
  if (loadOrder.length === 0) {
    console.log('[預載] 所有月份都已載入，跳過預載');
    return;
  }
  
  console.log('[預載] 需要載入的月份數:', loadOrder.length, '載入順序:', loadOrder.map(item => `${item.name}(${item.sheetIndex})`).join(', '));
  
  let loadedCount = 0;
  
  // 按順序載入（一個接一個，不是並發）
  for (const item of loadOrder) {
    console.log(`[預載] 開始載入月份 ${item.name} (sheetIndex: ${item.sheetIndex})`);
    try {
      // 使用獨立的 AbortController，避免與用戶操作衝突
      const monthData = await loadMonthData(item.sheetIndex, false);
      allMonthsData[item.sheetIndex] = monthData;
      
      console.log(`[預載] 成功載入月份 ${item.name} (sheetIndex: ${item.sheetIndex})`);
      console.log(`[預載] ${item.name} 資料 keys:`, Object.keys(monthData.data || {}));
      console.log(`[預載] ${item.name} 總計:`, monthData.total);
      
      // 更新進度條
      loadedCount++;
      if (totalProgress > 0) {
        updateProgress(baseProgress + loadedCount, totalProgress, `載入月份 ${item.name}`);
      }
      
      // 如果遇到還沒完成的，就跳出（顯示進度條）
      // 這裡我們繼續載入，但進度條會持續更新
    } catch (error) {
      // 即使失敗也更新進度
      loadedCount++;
      if (totalProgress > 0) {
        updateProgress(baseProgress + loadedCount, totalProgress, `載入月份 ${item.name}`);
      }
      
      // 輸出錯誤訊息以便除錯
      console.error(`[預載] 載入月份 ${item.name} (sheetIndex: ${item.sheetIndex}) 失敗:`, error);
      
      // 如果遇到錯誤，繼續載入下一個月份（不中斷）
    }
  }
  
  console.log('[預載] 預載完成，allMonthsData keys:', Object.keys(allMonthsData));
  Object.keys(allMonthsData).forEach(key => {
    const monthData = allMonthsData[key];
    const total = Array.isArray(monthData.total) ? monthData.total : 'N/A';
    const dataKeys = Object.keys(monthData.data || {});
    console.log(`[預載] sheetIndex ${key}: 總計=${total}, 資料 keys=${dataKeys.length} (${dataKeys.join(', ')})`);
  });
};

// 從記憶體載入當前月份的資料（不發送請求）
const loadContentFromMemory = () => {
  console.log('[記憶體載入] 開始從記憶體載入資料');
  console.log('[記憶體載入] currentSheetIndex:', currentSheetIndex);
  console.log('[記憶體載入] allMonthsData keys:', Object.keys(allMonthsData));
  
  // 先清空目前的記錄（確保不同月份的資料不會混在一起）
  allRecords = [];
  filteredRecords = [];
  currentRecordIndex = 0;

  // 驗證 currentSheetIndex 是否有效
  if (!Number.isFinite(currentSheetIndex) || currentSheetIndex < 2) {
    currentSheetIndex = 2; // 預設為第三個分頁
    console.log('[記憶體載入] currentSheetIndex 無效，設為預設值 2');
  }

  // 從記憶體讀取資料
  const monthData = allMonthsData[currentSheetIndex];
  if (!monthData) {
    console.log(`[記憶體載入] 找不到 sheetIndex ${currentSheetIndex} 的資料，需要重新載入`);
    return false; // 表示需要重新載入
  }

  console.log(`[記憶體載入] 找到資料，keys:`, Object.keys(monthData.data || {}));
  console.log(`[記憶體載入] 總計:`, monthData.total);

  // 處理資料（會自動過濾並顯示記錄）
  processDataFromResponse(monthData.data, true);
  
  console.log(`[記憶體載入] 處理後，allRecords.length:`, allRecords.length);
  console.log(`[記憶體載入] 處理後，filteredRecords.length:`, filteredRecords.length);
  
  // 更新總計
  updateTotalDisplay(monthData.total);
  
  // 確保顯示第一筆記錄（如果有的話，且不在新增模式）
  if (!isNewMode && filteredRecords.length > 0) {
    showRecord(0);
  }
  
  console.log('[記憶體載入] 成功從記憶體載入');
  return true; // 表示成功從記憶體載入
};

// 載入當前月份的資料（優先從記憶體讀取，如果沒有則發送請求）
const loadContent = async (forceReload = false) => {
  // 如果不強制重新載入，先嘗試從記憶體讀取
  if (!forceReload && loadContentFromMemory()) {
    return; // 成功從記憶體載入，直接返回
  }

  // 如果記憶體中沒有資料，或需要強制重新載入，則發送請求
  try {
    const monthData = await loadMonthData(currentSheetIndex);
    
    // 更新記憶體中的資料
    allMonthsData[currentSheetIndex] = monthData;
    
    // 處理資料
    processDataFromResponse(monthData.data);
    
    // 更新總計
    updateTotalDisplay(monthData.total);
  } catch (error) {
    throw error;
  }
};


const loadTotal = async () => {
  // 驗證 currentSheetIndex 是否有效
  if (!Number.isFinite(currentSheetIndex) || currentSheetIndex < 2) {
    currentSheetIndex = 2; // 預設為第三個分頁
  }
  
  // 優先從記憶體讀取總計
  const monthData = allMonthsData[currentSheetIndex];
  if (monthData && monthData.total) {
    updateTotalDisplay(monthData.total);
    return;
  }
  
  // 如果記憶體中沒有，則發送請求
  try {
    const TotalParams = { name: "Show Total", sheet: currentSheetIndex };
  const Totalurl = `${base}?${new URLSearchParams(TotalParams)}`;
    const Totalres = await fetch(Totalurl, {
      method: "GET",
      redirect: "follow",
      mode: "cors"
    });
    
    if (!Totalres.ok) {
      throw new Error(`載入總計失敗: HTTP ${Totalres.status} ${Totalres.statusText}`);
    }
    
  const Totaldata = await Totalres.json();
    
    // 更新記憶體中的總計（如果資料存在）
    if (allMonthsData[currentSheetIndex]) {
      allMonthsData[currentSheetIndex].total = Totaldata;
    } else {
      // 如果資料不存在，創建一個新的條目
      allMonthsData[currentSheetIndex] = { total: Totaldata };
    }
    
    updateTotalDisplay(Totaldata);
  } catch (error) {
    // 不拋出錯誤，只記錄，避免影響其他功能
  }
};

// 更新進度條
const updateProgress = (current, total, text = '載入中...') => {
  const progressContainer = document.getElementById('loading-progress');
  if (!progressContainer) return;
  
  const percentage = total > 0 ? Math.min(100, Math.round((current / total) * 100)) : 0;
  const progressBar = progressContainer.querySelector('.progress-bar');
  const progressText = progressContainer.querySelector('.progress-text');
  
  if (progressBar) {
    progressBar.style.width = `${percentage}%`;
  }
  if (progressText) {
    progressText.textContent = `${text} (${current}/${total})`;
  }
};

const showSpinner = () => {
  // 如果已經存在，先移除
  const existingOverlay = document.getElementById('loading-overlay');
  if (existingOverlay) {
    existingOverlay.remove();
  }
  
  // 創建全屏遮罩（不覆蓋頁首）
  const overlay = document.createElement('div');
  overlay.id = 'loading-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 60px;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(255, 255, 255, 0.95);
    z-index: 1500; /* 低於頁首 (2000)，不擋住漢堡選單與選項 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: not-allowed;
  `;
  
  const progressContainer = document.createElement('div');
  progressContainer.id = 'loading-progress';
  progressContainer.innerHTML = `
    <div style="width: 300px; text-align: center;">
      <div class="progress-text" style="font-size: 16px; margin-bottom: 15px; color: #333;">載入中... (0/0)</div>
      <div style="width: 100%; height: 8px; background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
        <div class="progress-bar" style="width: 0%; height: 100%; border-radius: 4px; transition: width 0.3s ease;"></div>
      </div>
    </div>
  `;
  
  overlay.appendChild(progressContainer);
  document.body.appendChild(overlay);
};

const hideSpinner = () => {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    // 先顯示「已完成」提示
    const progressContainer = document.getElementById('loading-progress');
    if (progressContainer) {
      progressContainer.innerHTML = `
        <div style="width: 300px; text-align: center;">
          <div style="font-size: 16px; margin-bottom: 15px; color: #2ecc71; font-weight: bold;">✓ 已完成</div>
          <div style="width: 100%; height: 8px; background-color: #e0e0e0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #2ecc71, #27ae60); border-radius: 4px; transition: width 0.3s ease;"></div>
          </div>
        </div>
      `;
    }
    
    // 延遲 800ms 後移除，讓用戶看到「已完成」提示
    setTimeout(() => {
      overlay.remove();
      const spinner = document.getElementById('loading-spinner');
      if (spinner) {
        spinner.remove();
      }
      const progress = document.getElementById('loading-progress');
      if (progress) {
        progress.remove();
      }
    }, 800);
  } else {
    const spinner = document.getElementById('loading-spinner');
    if (spinner) {
      spinner.remove();
    }
    const progress = document.getElementById('loading-progress');
    if (progress) {
      progress.remove();
    }
  }
};

const createInputRow = (labelText, inputId, inputType = 'text') => {
  const row = document.createElement('div');
  row.className = 'input-row';
  
  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = inputId; // 關聯到 input
  
  const input = document.createElement('input');
  input.id = inputId;
  input.name = inputId; // 添加 name 屬性以支持自動填充
  input.type = inputType;
  
  row.appendChild(label);
  row.appendChild(input);
  return row;
};

const createTextareaRow = (labelText, textareaId, rows = 3) => {
  const row = document.createElement('div');
  row.className = 'input-row';
  
  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = textareaId; // 關聯到 textarea
  
  const textarea = document.createElement('textarea');
  textarea.id = textareaId;
  textarea.name = textareaId; // 添加 name 屬性以支持自動填充
  textarea.rows = rows;
  
  row.appendChild(label);
  row.appendChild(textarea);
  return row;
};

const createSelectRow = (labelText, selectId, options) => {
  const row = document.createElement('div');
  row.className = 'select-row';
  
  const label = document.createElement('label');
  label.textContent = labelText;
  label.htmlFor = selectId; // 關聯到 select
  
  const selectContainer = document.createElement('div');
  selectContainer.className = 'select-container';
  
  const selectDisplay = document.createElement('div');
  selectDisplay.className = 'select-display';
  
  const selectText = document.createElement('div');
  selectText.className = 'select-text';
  selectText.textContent = options[0].text;
  
  const selectArrow = document.createElement('div');
  selectArrow.className = 'select-arrow';
  selectArrow.textContent = '▼';
  
  selectDisplay.appendChild(selectText);
  selectDisplay.appendChild(selectArrow);
  
  const hiddenSelect = document.createElement('select');
  hiddenSelect.id = selectId;
  hiddenSelect.name = selectId; // 添加 name 屬性以支持自動填充
  hiddenSelect.style.display = 'none';
  hiddenSelect.value = options[0].value;
  
  const dropdown = document.createElement('div');
  dropdown.className = 'select-dropdown';
  
  options.forEach(opt => {
    const option = document.createElement('div');
    option.className = 'select-option';
    option.textContent = opt.text;
    option.dataset.value = opt.value;
    
    option.addEventListener('click', function() {
      selectText.textContent = opt.text;
      hiddenSelect.value = opt.value;
      dropdown.style.display = 'none';
      selectArrow.style.transform = 'rotate(0deg)';
      hiddenSelect.dispatchEvent(new Event('change'));
    });
    
    dropdown.appendChild(option);
    const hiddenOption = document.createElement('option');
    hiddenOption.value = opt.value;
    hiddenOption.textContent = opt.text;
    hiddenSelect.appendChild(hiddenOption);
  });
  
  selectDisplay.addEventListener('click', function(e) {
    e.stopPropagation();
    const isOpen = dropdown.style.display === 'block';
    dropdown.style.display = isOpen ? 'none' : 'block';
    selectArrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
  });
  
  document.addEventListener('click', function(e) {
    if (!selectContainer.contains(e.target)) {
      dropdown.style.display = 'none';
      selectArrow.style.transform = 'rotate(0deg)';
    }
  });
  
  selectContainer.appendChild(selectDisplay);
  selectContainer.appendChild(dropdown);
  selectContainer.appendChild(hiddenSelect);
  
  row.appendChild(label);
  row.appendChild(selectContainer);
  return row;
};

const updateDivVisibility = (forceType = null) => {
  // 如果提供了類型參數，使用它；否則嘗試從 DOM 獲取最新元素的值
  let categoryValue = forceType;
  if (categoryValue === null) {
    // 先嘗試從全局變數獲取
    if (typeof categorySelect !== 'undefined' && categorySelect.value) {
      categoryValue = categorySelect.value;
    } else {
      // 如果全局變數不可用，從 DOM 獲取最新元素
      const categorySelectElement = document.getElementById('category-select');
      if (categorySelectElement) {
        categoryValue = categorySelectElement.value;
      } else {
        categoryValue = '支出'; // 默認值
      }
    }
  }
  
  div2.innerHTML = '';
  div3.innerHTML = '';
  div4.innerHTML = '';
  
  if (categoryValue === '支出') {
    const categoryRow = createSelectRow('類別：', 'expense-category-select', EXPENSE_CATEGORY_OPTIONS);
    const costRow = createInputRow('金額：', 'cost-input', 'number');
    const noteRow = createTextareaRow('備註：', 'note-input', 3);
    noteRow.style.marginBottom = '0px';
    
    div2.appendChild(categoryRow);
    div3.appendChild(costRow);
    div4.appendChild(noteRow);
    
    itemContainer.style.display = 'flex';
    div2.style.display = 'flex';
    div3.style.display = 'flex';
    div4.style.display = 'flex';
  } else if (categoryValue === '收入') {
    const costRow = createInputRow('金額：', 'cost-input', 'number');
    const noteRow = createTextareaRow('備註：', 'note-input', 3);
    noteRow.style.marginBottom = '0px';
    
    div2.appendChild(costRow);
    div3.appendChild(noteRow);
    
    itemContainer.style.display = 'flex';
    div2.style.display = 'flex';
    div3.style.display = 'flex';
    div4.style.display = 'none';
  }
};

const saveData = async () => {
  const categoryValue = categorySelect.value;
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  const TotalParams = { name: "Show Total", sheet: currentSheetIndex };
  
  if (!itemInput || !costInput) {
    alert('請等待表單載入完成');
    return;
  }
  
  const item = itemInput.value.trim();
  const costValue = costInput.value.trim();
  const cost = parseFloat(costValue);
  const note = noteInput ? noteInput.value.trim() : '';
  
  if (!item) {
    alert('請輸入項目');
    return;
  }
  
  if (!costValue || isNaN(cost) || cost <= 0) {
    alert('請輸入有效金額');
    return;
  }
  
  let category = '';
  let range = 0;
  
  if (categoryValue === '支出') {
    const div2Display = window.getComputedStyle(div2).display;
    if (div2Display === 'none' || div2Display === '') {
      alert('請等待表單載入完成');
      return;
    }
    const categorySelectElement = document.getElementById('expense-category-select');
    if (!categorySelectElement) {
      alert('請等待表單載入完成');
      return;
    }
    if (!categorySelectElement.value) {
      alert('請選擇支出類別');
      return;
    }
    category = categorySelectElement.value;
    range = 0;
  } else {
    range = 1;
  }
  
  
  // 鎖定整個頁面，等待後端回傳
  showSpinner();
  saveButton.textContent = '儲存中...';
  saveButton.disabled = true;
  saveButton.style.opacity = '0.6';
  saveButton.style.cursor = 'not-allowed';
  
  // 禁用所有輸入和按鈕
  if (itemInput) itemInput.disabled = true;
  if (costInput) costInput.disabled = true;
  if (noteInput) noteInput.disabled = true;
  if (categorySelect) categorySelect.disabled = true;
  const expenseCategorySelect = document.getElementById('expense-category-select');
  if (expenseCategorySelect) expenseCategorySelect.disabled = true;
  leftArrow.disabled = true;
  rightArrow.disabled = true;
  deleteButton.disabled = true;
  if (monthSelect) monthSelect.disabled = true;
  
  let alreadyReset = false; // 確保只在合適時機還原按鈕狀態
  try {
    const postData = {
      name: "Upsert Data",
      sheet: currentSheetIndex,
      range: range,
      item: item,
      cost: cost,
      note: note,
      
    };
    
    // 支出時（range === 0）必須發送 category
    if (range === 0) {
      postData.category = category;
    }
    
    // 如果不是新增模式，必須傳送 updateRow 參數來更新現有記錄
    // updateRow 是行號 = 編號 + 2（第一行是標題，資料從第二行開始）
    if (!isNewMode) {
      if (filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length) {
        const currentRecord = filteredRecords[currentRecordIndex];
        const recordNum = parseInt(currentRecord.row[0], 10);
        if (Number.isFinite(recordNum) && recordNum > 0) {
          postData.updateRow = recordNum + 2;
        } else {
          alert('無法更新記錄：找不到記錄編號');
          return;
        }
      } else {
        alert('無法更新記錄：找不到目前記錄');
        return;
      }
    }

    
    const response = await fetch(base, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      headers: {
        "Content-Type": "text/plain;charset=utf-8",
      },
      body: JSON.stringify(postData)
    });
    
    const responseText = await response.text();
    
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      throw new Error('後端響應格式錯誤: ' + responseText);
    }
    
    if (response.ok && result.success) {
      // 記錄是否在新增模式
      const wasInNewMode = isNewMode;
      const savedType = categoryValue;
      // 記錄目前編輯的記錄編號（用於編輯模式）
      const savedRecordNumber = !wasInNewMode && filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length 
        ? parseInt(filteredRecords[currentRecordIndex].row[0], 10) 
        : null;
      
      alert('資料已成功儲存！');
      
      // 在重新載入前，先設定 currentRecordNumber（用於編輯模式）
      if (!wasInNewMode && savedRecordNumber !== null) {
        currentRecordNumber = savedRecordNumber;
      }
      
      // 如果 Apps Script 回傳了 data 和 total，直接使用，否則重新載入
      if (result.data && result.total) {
        // 更新記憶體中當前月份的資料
        allMonthsData[currentSheetIndex] = {
          data: result.data,
          total: result.total
        };
        
        // 記錄當前顯示的記錄編號（用於更新後重新定位）
        const currentDisplayedRecordNumber = !wasInNewMode && filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length
          ? parseInt(filteredRecords[currentRecordIndex].row[0], 10)
          : null;
        
        // 使用回傳的資料更新記錄和總計（不自動過濾，稍後手動過濾）
        processDataFromResponse(result.data, false);
        updateTotalDisplay(result.total);
        
        // 根據保存的類型重新過濾記錄
        const currentType = categorySelect ? categorySelect.value : savedType;
        filterRecordsByType(currentType);
        
        // 等待過濾完成
        await new Promise(r => setTimeout(r, 100));
        
        // 如果剛才在編輯模式，嘗試找到剛才編輯的記錄並定位
        if (!wasInNewMode && currentDisplayedRecordNumber !== null) {
          const recordIndex = filteredRecords.findIndex(r => {
            const num = parseInt(r.row[0], 10);
            return Number.isFinite(num) && num > 0 && num === currentDisplayedRecordNumber;
          });
          
          if (recordIndex >= 0) {
            currentRecordIndex = recordIndex;
            showRecord(recordIndex);
            updateArrowButtons();
          } else {
            // 如果找不到，顯示第一筆
            if (filteredRecords.length > 0) {
              currentRecordIndex = 0;
              showRecord(0);
              updateArrowButtons();
            }
          }
        } else {
          // 新增模式或找不到記錄時，重置索引
          currentRecordIndex = 0;
          if (filteredRecords.length > 0) {
            showRecord(0);
            updateArrowButtons();
          }
        }
      } else {
      // 重新載入記錄（避免快取，加入短延遲）
      try {
        await new Promise(r => setTimeout(r, 200));
        await loadContent();
        } catch (e) {
        }
      }
        
        // 如果剛才在新增模式，自動進入下一個新增卡片
        if (wasInNewMode) {
          // 確保類型正確
          if (categorySelect && categorySelect.value !== savedType) {
            categorySelect.value = savedType;
            categorySelectText.textContent = savedType;
            filterRecordsByType(savedType);
          }
          
          // 等待過濾完成後，進入新增模式
          setTimeout(() => {
            // 計算下一個編號
            let nextNumber = 1;
            if (filteredRecords.length > 0) {
              const maxNum = Math.max(
                ...filteredRecords
                  .map(r => parseInt(r.row[0], 10))
                  .filter(n => Number.isFinite(n) && n > 0)
              );
              if (Number.isFinite(maxNum) && maxNum > 0) {
                nextNumber = maxNum + 1;
              }
            }
            
            // 進入新增模式
            isNewMode = true;
            currentRecordIndex = filteredRecords.length > 0 ? filteredRecords.length - 1 : 0;
            updateDeleteButton(); // 更新刪除按鈕顯示
            
            // 清空表單
            const itemInput = document.getElementById('item-input');
            const costInput = document.getElementById('cost-input');
            const noteInput = document.getElementById('note-input');
            if (itemInput) itemInput.value = '';
            if (costInput) costInput.value = '';
            if (noteInput) noteInput.value = '';
            
            // 新增模式不顯示編號
            if (typeof recordNumber !== 'undefined') {
              recordNumber.textContent = ''; // 新增模式不顯示編號
              recordNumber.style.display = 'none'; // 隱藏編號
            }
            
            // 新增下一筆時，「資料時間」使用現在時間
            if (typeof recordDate !== 'undefined') {
              recordDate.textContent = getNowFormattedDateTime();
            }
            
            // 如果是支出，重置類別選擇
            if (savedType === '支出') {
              const categorySelectElement = document.getElementById('expense-category-select');
              if (categorySelectElement && categorySelectElement.options.length > 0) {
                categorySelectElement.value = categorySelectElement.options[0].value;
                const selectContainer = categorySelectElement.parentElement;
                if (selectContainer) {
                  const selectDisplay = selectContainer.querySelector('div');
                  if (selectDisplay) {
                    const selectText = selectDisplay.querySelector('div');
                    if (selectText) {
                      selectText.textContent = categorySelectElement.options[0].textContent;
                    }
                  }
                }
              }
            }
            
            updateArrowButtons();
          }, 100);
        } else {
          // 如果不是新增模式（編輯模式），重新顯示剛才編輯的記錄
          if (savedRecordNumber !== null) {
            // 等待過濾完成後，找到剛才編輯的記錄並顯示
            // 使用較長的延遲，確保 loadContent 和 filterRecordsByType 完成
            setTimeout(() => {
              const recordIndex = filteredRecords.findIndex(r => {
                const num = parseInt(r.row[0], 10);
                return Number.isFinite(num) && num > 0 && num === savedRecordNumber;
              });
              
              if (recordIndex >= 0) {
                currentRecordIndex = recordIndex;
                showRecord(recordIndex);
                updateArrowButtons();
              } else {
                // 如果找不到，顯示第一筆
                if (filteredRecords.length > 0) {
                  currentRecordIndex = 0;
                  showRecord(0);
                  updateArrowButtons();
                }
              }
            }, 300);
          } else {
            // 如果找不到記錄編號，顯示第一筆
            setTimeout(() => {
              if (filteredRecords.length > 0) {
                currentRecordIndex = 0;
                showRecord(0);
                updateArrowButtons();
              }
            }, 100);
          }
        }
      
      // 總計更新完成後，才還原按鈕狀態
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
      alreadyReset = true;
    } else {
      const errorMessage = result.message || result.error || '未知錯誤';
      alert('儲存失敗: ' + errorMessage);
      // 失敗時還原按鈕狀態
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
      alreadyReset = true;
    }
  } catch (error) {
    alert('儲存失敗: ' + error.message);
    // 例外時還原按鈕狀態
    saveButton.textContent = '儲存';
    saveButton.disabled = false;
    saveButton.style.opacity = '1';
    saveButton.style.cursor = 'pointer';
    alreadyReset = true;
  } finally {
    // 恢復所有按鈕和輸入
    hideSpinner();
    if (!alreadyReset) {
      saveButton.textContent = '儲存';
      saveButton.disabled = false;
      saveButton.style.opacity = '1';
      saveButton.style.cursor = 'pointer';
    }
    
    // 恢復所有輸入和按鈕
    if (itemInput) itemInput.disabled = false;
    if (costInput) costInput.disabled = false;
    if (noteInput) noteInput.disabled = false;
    if (categorySelect) categorySelect.disabled = false;
    const expenseCategorySelect = document.getElementById('expense-category-select');
    if (expenseCategorySelect) expenseCategorySelect.disabled = false;
    leftArrow.disabled = false;
    rightArrow.disabled = false;
    deleteButton.disabled = false;
    if (monthSelect) monthSelect.disabled = false;
  }
};
 

const totalContainer = document.createElement('div');
totalContainer.className = 'total-container';

const budgetCardsContainer = document.createElement('div');
budgetCardsContainer.className = 'budget-cards-container';

const headerInfo = document.createElement('div');
headerInfo.className = 'header-info';

const recordNumber = document.createElement('div');
recordNumber.id = 'record-number';
recordNumber.textContent = '#001';

const recordDate = document.createElement('div');
recordDate.id = 'record-date';
recordDate.textContent = ''; // 顯示每筆記錄的時間（例如試算表中的最後修正時間）

headerInfo.appendChild(recordNumber);
headerInfo.appendChild(recordDate);

// 將月份下拉選單放在頁面標題右側（例如「預算表」右邊）
document.addEventListener('DOMContentLoaded', () => {
  const titleEl = document.querySelector('.post-title');
  if (titleEl && monthSelectWrapper) {
    titleEl.appendChild(monthSelectWrapper);
  }
});

// 刪除按鈕（垃圾桶）
const deleteButton = document.createElement('button');
deleteButton.className = 'delete-button';
deleteButton.innerHTML = '🗑️';

// 刪除當前記錄的函數（可被按鈕和鍵盤調用）
const deleteCurrentRecord = async () => {
  // 新增模式不能刪除
  if (isNewMode) {
    alert('無法刪除：目前為新增模式');
    return;
  }
  
  // 確認刪除
  if (!confirm('確定要刪除這筆記錄嗎？')) {
    return;
  }
  
  if (!filteredRecords.length || currentRecordIndex >= filteredRecords.length) {
    alert('無法刪除：找不到目前記錄');
    return;
  }
  
  const currentRecord = filteredRecords[currentRecordIndex];
  const recordNum = parseInt(currentRecord.row[0], 10);
  const recordType = currentRecord.type;
  
  if (!Number.isFinite(recordNum) || recordNum <= 0) {
    alert('無法刪除：找不到記錄編號');
    return;
  }
  
  // 確定 rangeType (0=支出, 1=收入)
  const rangeType = recordType === '支出' ? 0 : 1;
  
  // 鎖定整個頁面，等待後端回傳
  showSpinner();
  deleteButton.disabled = true;
  
  // 禁用所有輸入和按鈕
  const itemInput = document.getElementById('item-input');
  const costInput = document.getElementById('cost-input');
  const noteInput = document.getElementById('note-input');
  if (itemInput) itemInput.disabled = true;
  if (costInput) costInput.disabled = true;
  if (noteInput) noteInput.disabled = true;
  if (categorySelect) categorySelect.disabled = true;
  const expenseCategorySelect = document.getElementById('expense-category-select');
  if (expenseCategorySelect) expenseCategorySelect.disabled = true;
  leftArrow.disabled = true;
  rightArrow.disabled = true;
  saveButton.disabled = true;
  if (monthSelect) monthSelect.disabled = true;
  
  try {
    const postData = {
      name: "Delete Data",
      sheet: currentSheetIndex,
      range: rangeType,
      number: recordNum.toString() // 確保是字串，因為 Google Apps Script 用字串比較
    };
    
    const response = await fetch(base, {
      method: "POST",
      redirect: "follow",
      mode: "cors",
      keepalive: true,
      headers: {
        "Content-Type": "text/plain;charset=utf-8",
      },
      body: JSON.stringify(postData)
    });
    
    const responseText = await response.text();
    let result;
    try {
      result = JSON.parse(responseText);
    } catch (e) {
      throw new Error('後端響應格式錯誤: ' + responseText);
    }
    
    if (response.ok && result.success) {
      alert('記錄已成功刪除！');
      
      // 如果 Apps Script 回傳了 data 和 total，直接使用，否則重新載入
      if (result.data && result.total) {
        // 更新記憶體中當前月份的資料
        allMonthsData[currentSheetIndex] = {
          data: result.data,
          total: result.total
        };
        
        // 使用回傳的資料更新記錄和總計
        processDataFromResponse(result.data, false);
        updateTotalDisplay(result.total);
        
        // 根據當前類型重新過濾記錄
        const currentType = categorySelect ? categorySelect.value : recordType;
        filterRecordsByType(currentType);
        
        // 等待過濾完成後再顯示記錄
        await new Promise(r => setTimeout(r, 100));
      } else {
        // 重新載入記錄（並更新記憶體）
      await new Promise(r => setTimeout(r, 200));
        await loadContent(true); // 強制重新載入
      }
      
      // 刪除後，顯示第一筆（如果還有記錄）
      await new Promise(r => setTimeout(r, 100));
        if (filteredRecords.length > 0) {
          currentRecordIndex = 0;
          showRecord(0);
          updateArrowButtons();
        } else {
          // 沒有記錄時，進入新增模式
          isNewMode = true;
          updateDeleteButton(); // 更新刪除按鈕顯示
          const itemInput = document.getElementById('item-input');
          const costInput = document.getElementById('cost-input');
          const noteInput = document.getElementById('note-input');
          if (itemInput) itemInput.value = '';
          if (costInput) costInput.value = '';
          if (noteInput) noteInput.value = '';
          if (typeof recordNumber !== 'undefined') {
          recordNumber.textContent = ''; // 新增模式不顯示編號
          recordNumber.style.display = 'none'; // 隱藏編號
          }
          // 新增模式無資料時，資料時間使用現在時間
          if (typeof recordDate !== 'undefined') {
          recordDate.value = getNowFormattedDateTime();
          }
          updateArrowButtons();
        }
    } else {
      const errorMessage = result.message || result.error || '未知錯誤';
      alert('刪除失敗: ' + errorMessage);
    }
  } catch (error) {
    alert('刪除失敗: ' + error.message);
  } finally {
    // 恢復所有按鈕和輸入
    hideSpinner();
    deleteButton.disabled = false;
    
    // 恢復所有輸入和按鈕
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.disabled = false;
    if (costInput) costInput.disabled = false;
    if (noteInput) noteInput.disabled = false;
    if (categorySelect) categorySelect.disabled = false;
    const expenseCategorySelect = document.getElementById('expense-category-select');
    if (expenseCategorySelect) expenseCategorySelect.disabled = false;
    leftArrow.disabled = false;
    rightArrow.disabled = false;
    saveButton.disabled = false;
    if (monthSelect) monthSelect.disabled = false;
  }
};

// 垃圾桶按鈕點擊事件
deleteButton.addEventListener('click', deleteCurrentRecord);

// 更新刪除按鈕顯示狀態
function updateDeleteButton() {
  // 新增模式時隱藏刪除按鈕
  if (isNewMode) {
    deleteButton.style.display = 'none';
  } else {
    deleteButton.style.display = 'flex';
  }
}

const leftArrow = document.createElement('button');
leftArrow.className = 'arrow-button left';
leftArrow.innerHTML = '‹';

const rightArrow = document.createElement('button');
rightArrow.className = 'arrow-button right';
rightArrow.innerHTML = '›';

// 左右鍵切換所有記錄
// 更新箭頭按鈕狀態
function updateArrowButtons() {
  // 如果沒有記錄且是新增模式，隱藏所有箭頭
  if (!filteredRecords.length && isNewMode) {
    leftArrow.style.display = 'none';
    rightArrow.style.display = 'none';
    return;
  }
  
  // 如果沒有記錄且不是新增模式，也隱藏所有箭頭
  if (!filteredRecords.length && !isNewMode) {
    leftArrow.style.display = 'none';
    rightArrow.style.display = 'none';
    return;
  }
  
  // 如果有記錄，正常顯示箭頭
  // 如果在新增模式，左箭頭顯示加號
  if (isNewMode) {
    leftArrow.style.display = 'flex';
    leftArrow.innerHTML = '+';
    leftArrow.classList.add('plus');
  } else {
    // 如果在第一筆記錄，隱藏左箭頭
    if (currentRecordIndex === 0) {
    leftArrow.style.display = 'none';
  } else {
  leftArrow.style.display = 'flex';
      leftArrow.innerHTML = '‹';
      leftArrow.classList.remove('plus');
    }
  }
  
  rightArrow.style.display = 'flex';
  
  // 如果在新增模式或最後一筆，右箭頭變成加號
  if (isNewMode || currentRecordIndex === filteredRecords.length - 1) {
    rightArrow.innerHTML = '+';
    rightArrow.classList.add('plus');
  } else {
    rightArrow.innerHTML = '›';
    rightArrow.classList.remove('plus');
  }
}

// 切換到上一筆記錄
function goToPreviousRecord() {
  // 如果在新增模式，點擊左箭頭（加號）進入新增模式
  if (isNewMode) {
    // 已經在新增模式，不需要做什麼，或者可以重新清空表單
    return;
  }
  
  if (!filteredRecords.length) return;
  
  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length) {
    currentRecordIndex = filteredRecords.length - 1;
  }
  
    currentRecordIndex = Math.max(0, currentRecordIndex - 1);
    if (currentRecordIndex < filteredRecords.length) {
    showRecord(currentRecordIndex);
    }
    updateArrowButtons();
}

// 切換到下一筆記錄或進入新增模式
function goToNextRecord() {
  if (!filteredRecords.length) return;
  
  // 確保 currentRecordIndex 在有效範圍內
  if (currentRecordIndex >= filteredRecords.length) {
    currentRecordIndex = filteredRecords.length - 1;
  }
  
  // 如果在最後一筆或新增模式，進入新增模式
  if (currentRecordIndex === filteredRecords.length - 1 || isNewMode) {
    isNewMode = true; // 進入新增模式
    updateDeleteButton(); // 更新刪除按鈕顯示
    
    // 清空表單，準備新增
    const itemInput = document.getElementById('item-input');
    const costInput = document.getElementById('cost-input');
    const noteInput = document.getElementById('note-input');
    if (itemInput) itemInput.value = '';
    if (costInput) costInput.value = '';
    if (noteInput) noteInput.value = '';
    
    // 計算下一個編號（目前類型中最大的編號 + 1）
    let nextNumber = 1;
    if (filteredRecords.length > 0) {
      const maxNum = Math.max(
        ...filteredRecords
          .map(r => parseInt(r.row[0], 10))
          .filter(n => Number.isFinite(n) && n > 0)
      );
      if (Number.isFinite(maxNum) && maxNum > 0) {
        nextNumber = maxNum + 1;
      }
    }
    
    // 新增模式不顯示編號
    if (typeof recordNumber !== 'undefined') {
      recordNumber.textContent = ''; // 新增模式不顯示編號
      recordNumber.style.display = 'none'; // 隱藏編號
    }
    
    // 新增模式的「資料時間」使用現在時間
    if (typeof recordDate !== 'undefined') {
      recordDate.textContent = getNowFormattedDateTime();
    }
    
    updateArrowButtons();
  } else {
    currentRecordIndex = Math.min(filteredRecords.length - 1, currentRecordIndex + 1);
    showRecord(currentRecordIndex);
    updateArrowButtons();
  }
}

// 箭頭按鈕事件
leftArrow.addEventListener('click', goToPreviousRecord);
rightArrow.addEventListener('click', goToNextRecord);

// 切換收入/支出類型
function switchType(targetType) {
    // 確保 categorySelect 元素存在
    const categorySelectElement = document.getElementById('category-select');
    if (!categorySelectElement) {
      return; // 如果元素不存在，直接返回
    }
    
    const currentType = categorySelectElement.value || '支出';
    
    // 如果目標類型與當前類型不同，則切換
    if (currentType !== targetType) {
      // 在非新增模式下，保存當前記錄編號，以便在目標類型中查找相同編號的記錄
      // 檢查是否為新增模式：如果 isNewMode 為 true 或沒有記錄，則為新增模式
      const isActuallyNewMode = isNewMode || (filteredRecords.length === 0);
      
      if (!isActuallyNewMode) {
        // 優先從當前記錄獲取編號
        if (filteredRecords.length > 0 && currentRecordIndex < filteredRecords.length) {
          const currentRecord = filteredRecords[currentRecordIndex];
          const recordNum = parseInt(currentRecord.row[0], 10);
          if (Number.isFinite(recordNum) && recordNum > 0) {
            currentRecordNumber = recordNum; // 保存當前編號
          }
        }
        // 如果從記錄獲取失敗，嘗試從顯示的編號元素中讀取
        if (currentRecordNumber === null && typeof recordNumber !== 'undefined') {
          const recordNumText = recordNumber.textContent;
          const match = recordNumText.match(/#(\d+)/);
          if (match && match[1]) {
            const recordNum = parseInt(match[1], 10);
            if (Number.isFinite(recordNum) && recordNum > 0) {
              currentRecordNumber = recordNum;
            }
          }
        }
      }
      
      // 先更新全局變數，這樣 updateDivVisibility 才能讀取到正確的值
      if (typeof categorySelect !== 'undefined') {
        categorySelect.value = targetType;
      }
      
      // 更新 DOM 元素
      categorySelectElement.value = targetType;
      
      // 更新顯示文字
      const selectContainer = categorySelectElement.parentElement;
      if (selectContainer) {
        const selectDisplay = selectContainer.querySelector('div');
        if (selectDisplay) {
          const selectText = selectDisplay.querySelector('div');
          if (selectText) {
            selectText.textContent = targetType;
          }
        }
      }
      
      // 先更新 UI 元素顯示（特別是支出/收入的欄位切換）
      if (typeof updateDivVisibility === 'function') {
        updateDivVisibility();
      }
      
      // 然後過濾記錄並更新 UI（filterRecordsByType 會自動處理相同編號的查找）
      // 使用 setTimeout 確保 updateDivVisibility 完成後再執行
      setTimeout(() => {
      // updateDivVisibility 會重新創建 expense-category-select 元素，需要重新獲取並更新
      const newCategorySelectElement = document.getElementById('expense-category-select');
        if (newCategorySelectElement) {
          // 更新新創建的元素的值（如果目標類型是支出，設置第一個選項；如果是收入，不需要設置）
          if (targetType === '支出' && newCategorySelectElement.options.length > 0) {
            newCategorySelectElement.value = newCategorySelectElement.options[0].value;
            // 同步更新自訂下拉顯示文字
            const newSelectContainer = newCategorySelectElement.parentElement;
            if (newSelectContainer) {
              const newSelectDisplay = newSelectContainer.querySelector('div');
              if (newSelectDisplay) {
                const newSelectText = newSelectDisplay.querySelector('div');
                if (newSelectText) {
                  newSelectText.textContent = newCategorySelectElement.options[0].textContent;
                }
              }
            }
          }
          
          // 更新全局變數的 value 屬性（雖然元素已更換，但我們可以通過更新屬性來保持一致性）
          // 實際上，由於 categorySelect 是 const，我們需要確保後續代碼使用 getElementById 獲取最新元素
          // 但為了兼容性，我們也更新全局變數的 value（如果元素還存在的話）
          if (typeof categorySelect !== 'undefined' && categorySelect.parentNode) {
            categorySelect.value = targetType;
          }
        }
        
        if (typeof filterRecordsByType === 'function') {
          filterRecordsByType(targetType);
        }
        
        // 更新相關 UI 元素
        if (typeof updateArrowButtons === 'function') {
          updateArrowButtons();
        }
        if (typeof updateDeleteButton === 'function') {
          updateDeleteButton();
        }
      }, 200);
  }
}

// 鍵盤事件（電腦左右鍵切換記錄，上下鍵切換收入/支出，Delete鍵刪除記錄）
document.addEventListener('keydown', (e) => {
  // 如果正在輸入文字，不觸發切換（但Delete鍵除外，因為它本身就是用於刪除的）
  const activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
    // Delete鍵在輸入框中時，只刪除文字，不觸發記錄刪除
    if (e.key === 'Delete' || e.key === 'Backspace') {
      return;
    }
    return;
  }
  
  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    goToPreviousRecord();
  } else if (e.key === 'ArrowRight') {
    e.preventDefault();
    goToNextRecord();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    // 向上鍵 = 切換到收入
    switchType('收入');
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    // 向下鍵 = 切換到支出
    switchType('支出');
  } else if (e.key === 'Delete' || e.key === 'Backspace') {
    e.preventDefault();
    // Delete鍵或Backspace鍵 = 刪除當前記錄
    deleteCurrentRecord();
  }
});

// 觸摸滑動事件（手機左右滑動切換記錄）
let touchStartX = 0;
let touchEndX = 0;

budgetCardsContainer.addEventListener('touchstart', (e) => {
  touchStartX = e.changedTouches[0].screenX;
}, { passive: true });

budgetCardsContainer.addEventListener('touchend', (e) => {
  touchEndX = e.changedTouches[0].screenX;
  const deltaX = touchEndX - touchStartX;
  
  // 處理水平滑動（水平距離大於 50px）
  if (Math.abs(deltaX) > 50) {
    if (deltaX > 0) {
      // 向右滑動 = 上一筆
      goToPreviousRecord();
    } else {
      // 向左滑動 = 下一筆
      goToNextRecord();
    }
  }
}, { passive: true });

const div1 = document.createElement('div');
div1.className = 'category-select-row';

const categoryLabel = document.createElement('label');
categoryLabel.className = 'category-select-label';
categoryLabel.textContent = '類別：';
categoryLabel.htmlFor = 'category-select'; // 關聯到 select

const categorySelectContainer = document.createElement('div');
categorySelectContainer.className = 'category-select-container';

const categorySelectDisplay = document.createElement('div');
categorySelectDisplay.className = 'category-select-display';

const categorySelectText = document.createElement('div');
categorySelectText.className = 'category-select-text';
categorySelectText.textContent = '支出';

const categorySelectArrow = document.createElement('div');
categorySelectArrow.className = 'category-select-arrow';
categorySelectArrow.textContent = '▼';

categorySelectDisplay.appendChild(categorySelectText);
categorySelectDisplay.appendChild(categorySelectArrow);

const categorySelect = document.createElement('select');
categorySelect.id = 'category-select'; // 添加 id 以支持 label 關聯
categorySelect.name = 'category-select'; // 添加 name 屬性以支持自動填充
categorySelect.style.display = 'none';
categorySelect.value = '支出';
const optionExpense = document.createElement('option');
optionExpense.value = '支出';
optionExpense.textContent = '支出';
const optionIncome = document.createElement('option');
optionIncome.value = '收入';
optionIncome.textContent = '收入';
categorySelect.appendChild(optionExpense);
categorySelect.appendChild(optionIncome);

const categoryDropdown = document.createElement('div');
categoryDropdown.className = 'category-dropdown';

const categoryOption1 = document.createElement('div');
categoryOption1.className = 'category-option';
categoryOption1.textContent = '支出';
categoryOption1.dataset.value = '支出';
categoryOption1.addEventListener('click', function() {
  categorySelectText.textContent = '支出';
  categorySelect.value = '支出';
  categoryDropdown.style.display = 'none';
  categorySelectArrow.style.transform = 'rotate(0deg)';
  categorySelect.dispatchEvent(new Event('change'));
});

const categoryOption2 = document.createElement('div');
categoryOption2.className = 'category-option';
categoryOption2.textContent = '收入';
categoryOption2.dataset.value = '收入';
categoryOption2.addEventListener('click', function() {
  categorySelectText.textContent = '收入';
  categorySelect.value = '收入';
  categoryDropdown.style.display = 'none';
  categorySelectArrow.style.transform = 'rotate(0deg)';
  categorySelect.dispatchEvent(new Event('change'));
});

categoryDropdown.appendChild(categoryOption1);
categoryDropdown.appendChild(categoryOption2);

categorySelectDisplay.addEventListener('click', function(e) {
  e.stopPropagation();
  const isOpen = categoryDropdown.style.display === 'block';
  categoryDropdown.style.display = isOpen ? 'none' : 'block';
  categorySelectArrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
});

document.addEventListener('click', function(e) {
  if (!categorySelectContainer.contains(e.target)) {
    categoryDropdown.style.display = 'none';
    categorySelectArrow.style.transform = 'rotate(0deg)';
  }
});

categorySelectContainer.appendChild(categorySelectDisplay);
categorySelectContainer.appendChild(categoryDropdown);
categorySelectContainer.appendChild(categorySelect);

const itemContainer = document.createElement('div');
itemContainer.className = 'item-container';
itemContainer.className = 'item-container';

const itemTitleInput = document.createElement('input');
itemTitleInput.id = 'item-input';
itemTitleInput.name = 'item-input'; // 添加 name 屬性以支持自動填充
itemTitleInput.type = 'text';
itemTitleInput.placeholder = '輸入項目名稱...';


itemContainer.appendChild(itemTitleInput);

const div2 = document.createElement('div');
div2.style.display = 'none';
const div3 = document.createElement('div');
div3.style.display = 'none';
const div4 = document.createElement('div');
div4.style.display = 'none';

const saveButton = document.createElement('button');
saveButton.textContent = '儲存';
saveButton.className = 'save-button';

const columnsContainer = document.createElement('div');
columnsContainer.className = 'columns-container';

const incomeColumn = document.createElement('div');
incomeColumn.className = 'income-column';

const incomeTitle = document.createElement('h3');
incomeTitle.className = 'income-title';
incomeTitle.textContent = '收入：';

const incomeAmount = document.createElement('div');
incomeAmount.className = 'income-amount';
incomeAmount.textContent = 0;

const expenseColumn = document.createElement('div');
expenseColumn.className = 'expense-column';

const expenseTitle = document.createElement('h3');
expenseTitle.className = 'expense-title';
expenseTitle.textContent = '支出：';

const expenseAmount = document.createElement('div');
expenseAmount.className = 'expense-amount';
expenseAmount.textContent = 0;

const totalColumn = document.createElement('div');
totalColumn.className = 'total-column';

const totalTitle = document.createElement('h3');
totalTitle.className = 'total-title';
totalTitle.textContent = '總計：';

const totalAmount = document.createElement('div');
totalAmount.className = 'total-amount';
totalAmount.textContent = 0;

const updateTotalColor = (value) => {
  const numValue = parseFloat(value) || 0;
  totalAmount.classList.remove('positive', 'negative');
  totalTitle.classList.remove('positive', 'negative');
  if (numValue > 0) {
    totalAmount.classList.add('positive');
    totalTitle.classList.add('positive');
  } else if (numValue < 0) {
    totalAmount.classList.add('negative');
    totalTitle.classList.add('negative');
  }
};

// 月份選擇下拉（置於圓餅圖上方）
let monthSelect = null;
const monthSelectWrapper = document.createElement('div');
monthSelectWrapper.className = 'month-select-wrapper';

const monthSelectLabel = document.createElement('span');
monthSelectLabel.className = 'month-select-label';
monthSelectLabel.textContent = '月份：';

monthSelect = document.createElement('select');
monthSelect.id = 'month-select';
monthSelect.name = 'month-select';
monthSelect.className = 'month-select';

monthSelectWrapper.appendChild(monthSelectLabel);
monthSelectWrapper.appendChild(monthSelect);

const submitContainer = document.createElement('div');
submitContainer.style.width = '100%';
submitContainer.style.display = 'flex';
submitContainer.style.justifyContent = 'center';
submitContainer.style.padding = '0';

// 載入月份列表
async function loadMonthNames() {
    const params = { name: "Show Tab Name" };
  const url = `${base}?${new URLSearchParams(params)}&_t=${Date.now()}`;
  const res = await fetch(url, {
      method: "GET",
      redirect: "follow",
    mode: "cors",
    cache: "no-store"
    });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    
    if (!Array.isArray(data) || data.length === 0) {
    return [];
    }
    
    sheetNames = data;
  return sheetNames;
}

// 初始化月份下拉選單
const initMonthSelect = async () => {
  if (!monthSelect) return;
  
  try {
    // 載入月份列表
    await loadMonthNames();
    
    if (sheetNames.length === 0) {
      return;
    }
    
    // 檢查當前月份是否已有表格，若沒有則請後端建立（支出表和預算表都需要）
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const currentMonthStr = `${year}${month}`;
    const hasCurrentMonth = sheetNames.includes(currentMonthStr);
    
    if (!hasCurrentMonth) {
      try {
        const createResult = await callAPI({ name: "Create Tab" });
        alert(createResult.message || `已建立新分頁：${currentMonthStr}`);
        // 重新載入月份列表
        await loadMonthNames();
      } catch (createError) {
        alert('無法自動建立本月表格，請稍後再試或手動建立。');
      }
    }
    
    // 清空舊選項
    monthSelect.innerHTML = '';
    
    // 建立選項
    sheetNames.forEach((name, idx) => {
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = name;
      monthSelect.appendChild(opt);
    });
    
    // 選擇最接近當前月份的分頁
    const closestSheetIndex = findClosestMonth();
    currentSheetIndex = closestSheetIndex;
    const selectIndex = currentSheetIndex - 2;
    if (selectIndex >= 0 && selectIndex < sheetNames.length) {
      monthSelect.value = String(selectIndex);
    }
    
    // 優先載入當前月份並立即顯示，其他月份在背景載入
    // 注意：spinner 已在 DOMContentLoaded 時顯示，這裡不需要再顯示
    const totalMonths = sheetNames.length;
    const totalProgress = totalMonths + 1; // 總進度 = 月份列表(1) + 所有月份
    
    // 一開始就顯示總數
    updateProgress(0, totalProgress, '載入月份列表');
    
    try {
      // 更新進度：載入月份列表完成
      updateProgress(1, totalProgress, '載入月份列表');
      
      // 找出當前月份在 sheetNames 中的索引
      const currentMonthIdx = sheetNames.findIndex((name, idx) => {
        const sheetIndex = idx + 2;
        return sheetIndex === currentSheetIndex;
      });
      
      // 找出下一個月（currentMonthIdx + 1）
      let nextMonthIdx = currentMonthIdx + 1;
      let targetSheetIndex = currentSheetIndex;
      let targetMonthName = sheetNames[currentMonthIdx] || '';
      
      if (nextMonthIdx < sheetNames.length) {
        // 有下一個月，載入下一個月
        targetSheetIndex = nextMonthIdx + 2;
        targetMonthName = sheetNames[nextMonthIdx];
        console.log(`[初始化] 找到下一個月 ${targetMonthName} (sheetIndex: ${targetSheetIndex})，將載入並顯示`);
      } else {
        // 沒有下一個月，使用當前月份
        console.log(`[初始化] 沒有下一個月，使用當前月份 ${targetMonthName} (sheetIndex: ${targetSheetIndex})`);
      }
      
      // 更新當前月份索引
      currentSheetIndex = targetSheetIndex;
      
      // 更新進度：載入目標月份
      updateProgress(2, totalProgress, `載入月份 ${targetMonthName}`);
      console.log(`[初始化] 開始載入目標月份 ${targetMonthName} (sheetIndex: ${targetSheetIndex})`);
      const targetMonthData = await loadMonthData(targetSheetIndex);
      allMonthsData[targetSheetIndex] = targetMonthData;
      
      console.log(`[初始化] 目標月份載入完成，資料 keys:`, Object.keys(targetMonthData.data || {}));
      console.log(`[初始化] 目標月份總計:`, targetMonthData.total);
      console.log(`[初始化] allMonthsData keys:`, Object.keys(allMonthsData));
      
      // 更新月份選擇器顯示
      if (monthSelect) {
        const targetIdx = sheetNames.indexOf(targetMonthName);
        if (targetIdx >= 0) {
          monthSelect.value = targetIdx.toString();
        }
      }
      
      // 立即處理並顯示目標月份資料
      processDataFromResponse(targetMonthData.data);
      updateTotalDisplay(targetMonthData.total);
      enterNewModeIfEmpty();
      updateDeleteButton();
      updateArrowButtons();
      
      // 立即關閉載入遮罩，開放頁面讓用戶使用
      hideSpinner();
      console.log('[初始化] 目標月份載入完成，頁面已開放');
      
      // 在背景預載其他月份的資料（不顯示進度條，靜默載入）
      console.log('[初始化] 開始在背景預載其他月份資料');
      preloadAllMonthsData(2, 0).then(() => {
        console.log('[初始化] 所有月份預載完成');
      }).catch((error) => {
        console.error('[初始化] 預載失敗:', error);
        // 背景預載失敗不影響用戶操作
      });
    } catch (e) {
      hideSpinner();
      // 如果目標月份載入失敗，嘗試從記憶體讀取
      if (loadContentFromMemory()) {
        enterNewModeIfEmpty();
        updateDeleteButton();
        updateArrowButtons();
      }
      
      // 在背景預載其他月份的資料（不阻塞）
      preloadAllMonthsData(2, totalProgress).catch(() => {
        // 背景預載失敗不影響當前操作
      });
    }
    
    // 下拉選單變更時，切換月份（從記憶體讀取，不發送請求）
    // 先移除舊的事件監聽器（如果存在）
    if (monthSelectChangeHandler) {
      monthSelect.removeEventListener('change', monthSelectChangeHandler);
    }
    
    monthSelectChangeHandler = async () => {
      // 防止快速連續切換
      if (isSwitchingMonth) {
        console.log('[切換月份] 正在切換中，跳過');
        return;
      }
      
      const idx = parseInt(monthSelect.value, 10);
      if (!Number.isFinite(idx) || idx < 0 || idx >= sheetNames.length) {
        console.log('[切換月份] 無效的索引:', idx);
        return;
      }
      
      // 如果選擇的是當前月份，不需要切換
      const newSheetIndex = idx + 2;
      const monthName = sheetNames[idx];
      console.log(`[切換月份] 切換到月份 ${monthName} (sheetIndex: ${newSheetIndex})`);
      console.log(`[切換月份] 目前 allMonthsData keys:`, Object.keys(allMonthsData));
      
      if (currentSheetIndex === newSheetIndex) {
        console.log('[切換月份] 已是當前月份，跳過');
        return;
      }
      
      isSwitchingMonth = true;
      const oldSheetIndex = currentSheetIndex;
      currentSheetIndex = newSheetIndex; // 轉為實際 sheet index（前兩個是「空白表」和「下拉選單」）
      
      // 切換月份時，離開新增模式並重置狀態
      isNewMode = false;
      currentRecordNumber = null;
      
          const itemInput = document.getElementById('item-input');
          const costInput = document.getElementById('cost-input');
          const noteInput = document.getElementById('note-input');
      const expenseCategorySelect = document.getElementById('expense-category-select');
      
      try {
        // 先嘗試從記憶體載入資料（不發送請求、不顯示載入動畫）
        console.log(`[切換月份] 嘗試從記憶體載入 sheetIndex ${currentSheetIndex}`);
        if (loadContentFromMemory()) {
          // 從記憶體載入成功，立即更新 UI
          console.log('[切換月份] 從記憶體載入成功');
          updateDeleteButton();
          updateArrowButtons();
          enterNewModeIfEmpty();
          isSwitchingMonth = false;
        } else {
          console.log(`[切換月份] 記憶體中沒有資料，需要重新載入 sheetIndex ${currentSheetIndex}`);
          // 記憶體中沒有資料時，顯示進度條並載入
          showSpinner();
          updateProgress(0, 1, `載入月份 ${monthName}`);
          
          try {
            // 載入該月份的資料
            const monthData = await loadMonthData(currentSheetIndex);
            allMonthsData[currentSheetIndex] = monthData;
            
            console.log(`[切換月份] 成功載入月份 ${monthName}，資料 keys:`, Object.keys(monthData.data || {}));
            console.log(`[切換月份] 總計:`, monthData.total);
            console.log(`[切換月份] 目前 allMonthsData keys:`, Object.keys(allMonthsData));
            
            // 處理並顯示資料
            processDataFromResponse(monthData.data);
            updateTotalDisplay(monthData.total);
            updateDeleteButton();
            updateArrowButtons();
            enterNewModeIfEmpty();
            
            // 載入完成後關閉進度條
            hideSpinner();
          } catch (error) {
            console.error(`載入月份 ${monthName} (sheetIndex: ${currentSheetIndex}) 失敗:`, error);
            alert(`載入月份 ${monthName} 失敗: ${error.message || error.toString()}`);
            // 恢復到原來的月份
            currentSheetIndex = oldSheetIndex;
            if (monthSelect) {
              const oldSelectIndex = oldSheetIndex - 2;
              if (oldSelectIndex >= 0 && oldSelectIndex < sheetNames.length) {
                monthSelect.value = String(oldSelectIndex);
              }
            }
            hideSpinner();
          } finally {
            isSwitchingMonth = false;
          }
        }
      } catch (e) {
        // 如果載入失敗，恢復原來的月份
        currentSheetIndex = oldSheetIndex;
        if (monthSelect) {
          const oldSelectIndex = oldSheetIndex - 2;
          if (oldSelectIndex >= 0 && oldSelectIndex < sheetNames.length) {
            monthSelect.value = String(oldSelectIndex);
          }
        }
        isSwitchingMonth = false;
          hideSpinner();
      }
    };
    
    monthSelect.addEventListener('change', monthSelectChangeHandler);
    
    // 初始載入目前選擇的月份資料（從記憶體讀取，不需要 spinner）
    // 如果記憶體中沒有資料，initMonthSelect 已經載入並顯示了
    if (loadContentFromMemory()) {
      // 從記憶體載入成功，只需要更新 UI
    updateDeleteButton();
    updateArrowButtons();
    }
  } catch (error) {
    // CORS / fetch 類錯誤在實際使用上不影響結果，這裡不再彈出提示視窗，避免干擾操作
  }
};


totalContainer.appendChild(columnsContainer);
  columnsContainer.appendChild(incomeColumn);
    incomeColumn.appendChild(incomeTitle);
    incomeColumn.appendChild(incomeAmount);
  columnsContainer.appendChild(expenseColumn);
    expenseColumn.appendChild(expenseTitle);
    expenseColumn.appendChild(expenseAmount);
  columnsContainer.appendChild(totalColumn);
    totalColumn.appendChild(totalTitle);
    totalColumn.appendChild(totalAmount);
budgetCardsContainer.appendChild(headerInfo);
budgetCardsContainer.appendChild(deleteButton);
budgetCardsContainer.appendChild(leftArrow);
budgetCardsContainer.appendChild(rightArrow);
budgetCardsContainer.appendChild(itemContainer);
budgetCardsContainer.appendChild(div1);
  div1.appendChild(categoryLabel);
  div1.appendChild(categorySelectContainer);
budgetCardsContainer.appendChild(div2);
budgetCardsContainer.appendChild(div3);
budgetCardsContainer.appendChild(div4);
budgetCardsContainer.appendChild(submitContainer);
  submitContainer.appendChild(saveButton);

categorySelect.addEventListener('change', () => {
  updateDivVisibility();
  if (allRecords.length > 0) {
    filterRecordsByType(categorySelect.value);
  }
});
updateDivVisibility();
saveButton.addEventListener('click', saveData);
saveButton.addEventListener('click', loadTotal);

document.addEventListener('DOMContentLoaded', async function() {
  // 立即顯示載入動畫，讓用戶知道頁面正在載入
  showSpinner();
  
  document.getElementsByClassName('post-content')[0].appendChild(totalContainer);
  document.getElementsByClassName('post-content')[0].appendChild(budgetCardsContainer);

  try {
    // 非阻塞載入「下拉選單」sheet 的最新選項
    const refreshDropdowns = () => {
      loadDropdownOptions().then(() => {
        // 如果當前顯示的是支出類別，重新渲染
        const categorySelect = document.getElementById('category-select');
        if (categorySelect && categorySelect.value === '支出') {
          updateDivVisibility('支出');
        }
      }).catch(err => {
      });
    };
    
    refreshDropdowns();

    // 監聽設定頁的更新通知（當設定頁更新下拉選單後，自動重新載入）
    window.addEventListener('storage', (e) => {
      if (e.key === 'dropdownUpdated') {
        refreshDropdowns();
      }
    });
    
    // 也監聽同頁面的 storage 事件（因為 storage 事件只在其他標籤頁觸發）
    let lastUpdateTime = localStorage.getItem('dropdownUpdated');
    setInterval(() => {
      const current = localStorage.getItem('dropdownUpdated');
      if (current && current !== lastUpdateTime) {
        lastUpdateTime = current;
        refreshDropdowns();
      }
    }, 1000); // 每秒檢查一次

    // initMonthSelect 內部會處理載入並在完成時隱藏 spinner
    await initMonthSelect(); // 先載入月份清單並載入對應月份資料
    updateDeleteButton(); // 初始化刪除按鈕顯示狀態
  } catch (error) {
    hideSpinner(); // 確保錯誤時也隱藏 spinner
    const errorContainer = document.createElement('div');
    errorContainer.innerHTML = '載入失敗: ' + error.message;
    errorContainer.style.color = 'red';
    errorContainer.style.marginTop = '20px';
    document.getElementsByClassName('post-content')[0].appendChild(errorContainer);
  }
});

</script>